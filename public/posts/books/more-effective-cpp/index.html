<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>More Effective C&#43;&#43; | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="这篇博客主要是用来加深自己对读过的书的记忆。写的内容可能只对我自己产生价值:smile:">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="More Effective C&#43;&#43;" />
<meta property="og:description" content="这篇博客主要是用来加深自己对读过的书的记忆。写的内容可能只对我自己产生价值:smile:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/books/more-effective-cpp/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="More Effective C&#43;&#43;"/>
<meta name="twitter:description" content="这篇博客主要是用来加深自己对读过的书的记忆。写的内容可能只对我自己产生价值:smile:"/>

<meta itemprop="name" content="More Effective C&#43;&#43;">
<meta itemprop="description" content="这篇博客主要是用来加深自己对读过的书的记忆。写的内容可能只对我自己产生价值:smile:"><meta itemprop="datePublished" content="2023-02-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-02-11T00:00:00+00:00" />
<meta itemprop="wordCount" content="599">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">11</span>
<span class="rest">Feb 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">More Effective C&#43;&#43;</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;3&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;599&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<h2 id="读书笔记-more-effective-c">读书笔记: More Effective C++</h2>
<p>这篇博客主要是用来加深自己对读过的书的记忆。写的内容可能只对我自己产生价值:smile:</p>
<h3 id="item-1-distinguish-between-pointers-and-references">Item 1: Distinguish between pointers and references</h3>
<p>引用相较于指针</p>
<p><strong>优势</strong> 他总是有效的，即没有null reference，指针则需要检查是否为空</p>
<p><strong>劣势</strong> 指针可以指向一个新的对象，引用不行。指针可以使用nullptr表示不存在，如果你需要该变量拥有不存在的语义，使用pointer。</p>
<p><strong>总结</strong> 当你确认你需要指向某个东西，并且绝对不会改变指向其它东西，使用reference，不然的话使用pointer</p>
<h3 id="item-2-prefer-c-style-casts">Item 2: Prefer C++-style casts</h3>
<p>C的转型，无法区分想做的是什么类型的转型，而且较难分辨，尽量使用C++的新式转型</p>
<ol>
<li><strong>static_cast</strong> 基本拥有C旧式转型的相同威力与意义</li>
<li><strong>cons_cast</strong> 用于强转const属性</li>
<li><strong>dynamic_cast</strong> 用于在继承体系中向下转型，转型失败时会以nullptr或者exception表现出来</li>
<li><strong>reinterpret_cast</strong> 用于转换二进制和序列化，或者函数指针的转型</li>
</ol>
<h3 id="item-3--never-treat-arrays-polymorphically-skull">Item 3:  Never treat arrays polymorphically :skull:</h3>
<p>数组类型不能被当作多态来进行传递，即</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">printBSTArray</span>(<span style="color:#080;font-weight:bold">const</span> BST array[]);
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">BalancedBST</span><span style="color:#333">:</span> <span style="color:#080;font-weight:bold">public</span> BST {};
</span></span><span style="display:flex;"><span>printBSTArray(BalancedBST) <span style="color:#888">// error!
</span></span></span></code></pre></div><p>Why? 当你读取数组元素时，偏移是根据你申明的类型来进行计算的，但是子类的大小和父类基本都是不一致的，因此你实际使用的偏移是错误的，这是一个未定义行为！</p>
<h3 id="item-4--avoid-gratuitous-default-constructors">Item 4:  Avoid gratuitous default constructors</h3>
<p>如果一个类不借助外部的信息就无法正确初始化，那么就应该避免提供默认构造函数，但这会带来以下几个问题</p>
<ol>
<li>对于数组类型 <strong>A a[10]</strong> 没有默认构造函数即无法生成，需要使用别的方式生成，例如使用指针数组，而不是对象数组</li>
<li>对于一些基于模板的容器类型无法很好的兼容，因为他们可能假设你的类拥有默认构造函数</li>
<li>如果virtual base class 缺乏默认构造函数，后续继承他的类都需要知道其意义(bad design)。</li>
</ol>
<p>结论，这是一个case by case的问题，根据实际情况进行抉择。</p>
<h3 id="item-5---be-wary-of-user-defined-conversion-functions">Item 5:   Be wary of user-defined conversion functions</h3>
<p>对于自己定义转换函数需要格外的小心，因为他们可能导致非预期的函数调用，编译器会想尽办法帮你编译成功，因此可能在你未预料的地方给你进行了隐饰转换，解决办法</p>
<ol>
<li>定义 **asType()**的成员函数，进行显式的类型转换</li>
<li>使用<strong>explicit</strong>去除单自变量的constructor的隐式转换</li>
</ol>
<h3 id="item-6--distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators">Item 6:  Distinguish between prefix and postfix forms of increment and decrement operators</h3>
<p>前置++返回引用，后置++返回const 对象(const 对象防止 a++++)</p>
<p>后置++有一个临时变量的负担。</p>
<p>prefer prefix</p>
<h3 id="item-7-never-overload---or-">Item 7: Never overload &amp;&amp;, ||, or ,</h3>
<p>这些符号是由短路特性，而且保证从左往右计算，如果你对其进行重载，函数传进来的参数是无法保证计算顺序的，会导致与常规理解不符，从而导致未定义行为。</p>
<h3 id="item-8--understand-the-different-meanings-of-new-and-delete">Item 8:  Understand the different meanings of new and delete</h3>
<p><strong>new</strong></p>
<ol>
<li>分配内存</li>
<li>在该内存上调用构造函数</li>
</ol>
<p><strong>operator new</strong>  （void* operator new(size_t size))</p>
<ol>
<li>返回一块原始的未初始化的内存</li>
</ol>
<p><strong>placement new</strong> ( new (memory pointer) Type(args) )</p>
<ol>
<li>在memory pointer上调用构造函数</li>
</ol>
<p><strong>new []  和 operator new[]</strong> 对应的数组版</p>
<p>delete 与new对应，需要成对出现</p>
<p>delete - new</p>
<p>operator delete - operator new</p>
<h3 id="item-9-use-destructors-to-prevent-resource-leaks">Item 9: Use destructors to prevent resource leaks</h3>
<p>因为有异常的存在，可能你释放资源之前就抛出了异常，导致资源泄漏。如果不断写catch会使代码乱七八糟，因此将资源释放放到析构函数中，即RAII</p>
<h3 id="item-10-prevent-resource-leaks-in-constructors">Item 10: Prevent resource leaks in constructors</h3>
<p>如果contructor抛出异常，因为对象尚未完全构建完全，因此析构函数不会被调用，从而导致内存泄漏，解决办法为尽量使member不要是指针并且为智能指针。</p>
<h3 id="item-11-prevent-exceptions-from-leaving-destructors">Item 11: Prevent exceptions from leaving destructors</h3>
<p>如果析构函数中抛出了异常有两个坏处1. 可能导致程序直接终止 2.导致析构函数需要执行的语句没有执行完，即内存泄漏，因此需要尽力避免析构函数抛出异常。</p>
<h3 id="item-12-understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function">Item 12: Understand how throwing an exception differs from passing a parameter or calling a virtual function</h3>
<ol>
<li>异常类型永远会复制一份，无论捕获方式是什么</li>
<li>被抛出作为exception的对象，其被允许的类型转化方式比被传递到函数的去的方式少</li>
<li>异常比对是第一个成功就执行，而不是最佳匹配。</li>
</ol>
<h3 id="item-13-catch-exceptions-by-reference">Item 13: Catch exceptions by reference</h3>
<p>用指针捕获，容易导致传进来的指针已经失效，或者不知道该不该释放这个指针</p>
<p>用值捕获，需要多复制一份且不支持多态</p>
<p>用引用捕获，没有缺点！</p>
<h3 id="item-14-use-exception-specifications-judiciously">Item 14: Use exception specifications judiciously</h3>
<p>C++11基本不怎么使用了，仅用noexcept</p>
<h3 id="item-15-understand-the-costs-of-exception-handling">Item 15: Understand the costs of exception handling</h3>
<p>使用profile去检查性能的影响</p>
<h3 id="item-16-remember-the-80-20-rule">Item 16: Remember the 80-20 rule</h3>
<p>在真正关键的地方进行努力</p>
<h3 id="item-17-consider-using-lazy-evaluation">Item 17: Consider using lazy evaluation</h3>
<p>经典的计算机思想，仅在需要时计算。</p>
<h3 id="item-18-amortize-the-cost-of-expected-computations">Item 18: Amortize the cost of expected computations</h3>
<p>将计算平坦到每一次调用中，例如你需要计算一个数组中的最大值，可以在每一次添加元素时，对最大值进行更新。</p>
<h3 id="item-19-understand-the-origin-of-temporary-objects">Item 19: Understand the origin of temporary objects</h3>
<p>临时对象可能很耗成本，所以应该尽可能消除它们。例如reference to const 以及 value的地方就可能产生临时对象.</p>
<h3 id="item-20-facilitate-the-return-value-optimization">Item 20: Facilitate the return value optimization</h3>
<p>详情看<a href="../C&#43;&#43;/rvo.md">RVO</a></p>
<h3 id="item-21--overload-to-avoid-implicit-type-conversions">Item 21:  Overload to avoid implicit type conversions</h3>
<p>使用重载来消除隐式转换，从而消除临时变量，例如</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">const</span> UPInt <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">+</span>(<span style="color:#080;font-weight:bold">const</span> UPInt<span style="color:#333">&amp;</span> lhs, <span style="color:#888">// add UPInt
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>					  <span style="color:#080;font-weight:bold">const</span> UPInt<span style="color:#333">&amp;</span> rhs); <span style="color:#888">// and UPInt
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">const</span> UPInt <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">+</span>(<span style="color:#080;font-weight:bold">const</span> UPInt<span style="color:#333">&amp;</span> lhs, <span style="color:#888">// add UPInt
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>					  <span style="color:#339;font-weight:bold">int</span> rhs); <span style="color:#888">// and int
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">const</span> UPInt <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">+</span>(<span style="color:#339;font-weight:bold">int</span> lhs, <span style="color:#888">// add int and
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>					  <span style="color:#080;font-weight:bold">const</span> UPInt<span style="color:#333">&amp;</span> rhs); <span style="color:#888">// UPInt
</span></span></span></code></pre></div><p>这样当执行 <strong>upi3 = upi1 + 10;</strong> 就不会有因为类型转换而产生临时变量。</p>
<h3 id="item-22-consider-using-op-instead-of-stand-alone-op">Item 22: Consider using op= instead of stand-alone op</h3>
<p>复合版本即+=，一般效率高于+，因为不需要产生临时变量。</p>
<h3 id="item-23-consider-alternative-libraries">Item 23: Consider alternative libraries</h3>
<p>这个没啥说的，有什么高性能库就用什么吧。</p>
<h3 id="item-24-understand-the-costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti">Item 24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI</h3>
<p>这个也没啥说的，只有实际碰到才能知道。</p>
<h3 id="item-25-virtualizing-constructors-and-non-member-functions">Item 25: Virtualizing constructors and non-member functions</h3>
<p>虚构造函数，实际就是一个虚static成员函数，在构造函数中调用，从而实现虚构造函数</p>
<p>虚non-member函数，写一个虚函数做实际工作，再安排非虚函数对其进行调用。</p>
<h3 id="item-26-limiting-the-number-of-objects-of-a-class">Item 26: Limiting the number of objects of a class</h3>
<p>设计一个Counted类，在内部进行计算，从而用户无感知</p>
<h3 id="item-27-requiring-or-prohibiting-heap-based-objects">Item 27: Requiring or prohibiting heap-based objects</h3>
<p>有一个hack的方式检查对象是否在heap中(利用程序的内存布局，但不具有可扩展性)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">onHeap</span>(<span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">void</span> <span style="color:#333">*</span>address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#339;font-weight:bold">char</span> onTheStack; <span style="color:#888">// local stack variable
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">return</span> address <span style="color:#333">&lt;</span> <span style="color:#333">&amp;</span>onTheStack;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们没有完美的方式来限制对象是否在heap中</p>
<h3 id="item-28-smart-pointers">Item 28: Smart pointers</h3>
<p>C++11 已经支持了</p>
<h3 id="item-29-reference-counting">Item 29: Reference counting</h3>
<p>经典问题，不展开了</p>
<h3 id="item-30-proxy-classes">Item 30: Proxy classes</h3>
<p>使用proxy对象来表示某些并不存在的对象，并且让用户无感知即为proxy classes</p>
<h3 id="item-31-making-functions-virtual-with-respect-to-more-than-one-object">Item 31: Making functions virtual with respect to more than one object</h3>
<p>multi dispatch，最佳解决手段，自己写虚表。</p>
<h3 id="item-32-program-in-the-future-tense">Item 32: Program in the future tense</h3>
<p>时刻想着自己写的代码会被各种扩展，以及各种神奇的需求</p>
<h3 id="item-33-make-non-leaf-classes-abstract">Item 33: Make non-leaf classes abstract</h3>
<p>专门抽象出Abstract类，让其他类来继承。</p>
<h3 id="item-34-understand-how-to-combine-c-and-c-in-the-same-program">Item 34: Understand how to combine C++ and C in the same program</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#579">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#579"></span><span style="color:#080;font-weight:bold">extern</span> <span style="background-color:#fff0f0">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#579">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#579"></span><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">drawLine</span>(<span style="color:#339;font-weight:bold">int</span> x1, <span style="color:#339;font-weight:bold">int</span> y1, <span style="color:#339;font-weight:bold">int</span> x2, <span style="color:#339;font-weight:bold">int</span> y2); <span style="color:#888">// 以这种方式避免编译器重命名
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">twiddleBits</span>(<span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">char</span> bits);
</span></span><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">simulate</span>(<span style="color:#339;font-weight:bold">int</span> iterations);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#579">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#579"></span>}
</span></span><span style="display:flex;"><span><span style="color:#579">#endif
</span></span></span></code></pre></div><p>If you want to mix C++ and C in the same program, remember the following simple guidelines:</p>
<p>■ Make sure the C++ and C compilers produce compatible object files.</p>
<p>■ Declare functions to be used by both languages extern &ldquo;C&rdquo;.</p>
<p>■ If at all possible, write main in C++.</p>
<p>■ Always use delete with memory from new; always use free with memory from malloc.</p>
<p>■ Limit what you pass between the two languages to data structures that compile under C; the C++ version of structs may contain nonvirtual member functions.</p>
<h3 id="item-35-familiarize-yourself-with-the-language-standard">Item 35: Familiarize yourself with the language standard</h3>
<p>熟悉语言标准！多看看RFC！</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/c&#43;&#43;/">c&#43;&#43;</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
