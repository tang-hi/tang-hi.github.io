<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>LevelDB(1) -- 写 | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的写操作，以及相应的文件格式.">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="LevelDB(1) -- 写" />
<meta property="og:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的写操作，以及相应的文件格式." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/database/leveldb-write/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-15T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="LevelDB(1) -- 写"/>
<meta name="twitter:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的写操作，以及相应的文件格式."/>

<meta itemprop="name" content="LevelDB(1) -- 写">
<meta itemprop="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的写操作，以及相应的文件格式."><meta itemprop="datePublished" content="2023-06-15T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-06-15T00:00:00+00:00" />
<meta itemprop="wordCount" content="887">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">15</span>
<span class="rest">Jun 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">LevelDB(1) -- 写</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;5&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;887&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>本文将介绍LevelDB是如何存储写入数据, 以及数据在磁盘中的存储格式.</p>
<h2 id="overview">Overview</h2>
<p>我们先看一下LevelDB整体的写流程是什么样子的.</p>
<div style="text-align: center">
<img src="/pic/levelDB/write-overview.png"/>
</div>
<p>从图中可以看出levelDB采用经典的WAL方式来进行写入,即先将写入的操作写到log文件中,再将实际的数据写到内存中的<code>Memtable</code>中(<code>Memtable</code>采用skipList实现),当<code>Memtable</code>达到阈值后再将其转化为<code>ImmutableMemTable</code>,最终将其落盘持久化保存.</p>
<p>因此本文后面将主要介绍</p>
<ol>
<li>log文件的格式与生成</li>
<li>memtable的实现</li>
<li>ldb文件的格式与生成</li>
</ol>
<h2 id="写操作的生成">写操作的生成</h2>
<p>在讲述文件的格式与生成之前,我们需要先描述写操作是如何生成.</p>
<p>当用户调用<code>DB::Put(const WriteOptions&amp; opt, const Slice&amp; key, const Slice&amp; value) </code>时,我们会将key,value包装成一个<code>WriteBatch</code>,顾名思义,<code>WriteBatch</code>中会有许多的写操作.其定义如下所示.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">LEVELDB_EXPORT</span> WriteBatch {
</span></span><span style="display:flex;"><span> <span style="color:#080;font-weight:bold">public</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>  WriteBatch();
</span></span><span style="display:flex;"><span>  <span style="color:#888">// skip ....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// Intentionally copyable.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  WriteBatch(<span style="color:#080;font-weight:bold">const</span> WriteBatch<span style="color:#333">&amp;</span>) <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">default</span>; <span style="color:#888">// 默认拷贝构造
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  WriteBatch<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span> <span style="color:#333">=</span>(<span style="color:#080;font-weight:bold">const</span> WriteBatch<span style="color:#333">&amp;</span>) <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">default</span>; <span style="color:#888">// 默认赋值构造
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// skip ....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// Store the mapping &#34;key-&gt;value&#34; in the database.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Put</span>(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> value);
</span></span><span style="display:flex;"><span>  <span style="color:#333">~</span>WriteBatch();
</span></span><span style="display:flex;"><span>  <span style="color:#888">// skip ....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span> <span style="color:#080;font-weight:bold">private</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#333">::</span>string rep_;  <span style="color:#888">// See comment in write_batch.cc for the format of rep_
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}  <span style="color:#888">// namespace leveldb
</span></span></span></code></pre></div><p>我们可以看到其本质就是一个<strong>string</strong>,我们会将写操作通过<code>Put</code>接口将其写入到rep_中,<code>WriteBatch</code>在内存中的格式如下图所示.</p>
<div style="text-align: center">
<img src="/pic/levelDB/write-batch.png"/>
</div>
<p>从图中可以看到，WriteBatch由<code>SequenceNumber</code>,<code>count</code>以及<code>count</code>个KV对组成, 其中前8个byte为<code>SequenceNumber</code>(LevelDB中写操作的唯一自增编号)，紧跟着的4个byte为存储的KV对个数。KV对则由<code>tag</code>,<code>key-size And key's content</code>, <code>value-size And value's content</code>构成。</p>
<p>其中<code>tag</code>为枚举类型,<code>kTypeDeletion</code>表明删除,<code>kTypeDeletion</code>表明增加.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">ValueType</span> {
</span></span><span style="display:flex;"><span>  kTypeDeletion <span style="color:#333">=</span> <span style="color:#058;font-weight:bold">0x0</span>,
</span></span><span style="display:flex;"><span>  kTypeValue <span style="color:#333">=</span> <span style="color:#058;font-weight:bold">0x1</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在生成WriteBatch后(此时WriteBatch中仅有用户输入的KV对)，我们生成Writer, 并将WriteBatch存入Writer中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">DBImpl</span><span style="color:#333">::</span>Writer {
</span></span><span style="display:flex;"><span>  Status status;
</span></span><span style="display:flex;"><span>  WriteBatch<span style="color:#333">*</span> batch;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> sync;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> done;
</span></span><span style="display:flex;"><span>  port<span style="color:#333">::</span>CondVar cv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">explicit</span> <span style="color:#06b;font-weight:bold">Writer</span>(port<span style="color:#333">::</span>Mutex<span style="color:#333">*</span> mu) <span style="color:#333">:</span> cv(mu) { }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>随后，我们会将Writer放到队列中（一个经典的生产者，消费者模型）。当该Writer为队首时才会被拿出来执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>writers_.push_back(<span style="color:#333">&amp;</span>w);
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">while</span> (<span style="color:#333">!</span>w.done <span style="color:#333">&amp;&amp;</span> <span style="color:#333">&amp;</span>w <span style="color:#333">!=</span> writers_.front()) {
</span></span><span style="display:flex;"><span>	w.cv.Wait();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当该Writer被拿出来执行时，我们首先会确保<code>Memtable</code>仍然有较为充足的空间给它进行写入，不然的话我们可能要进行compact(目前可以不关注，后续在讲compact的时候会详细阐述，这里先假定空间一定充足)。</p>
<p>此时，我们会尝试将多个WriterBatch合并为一个后一起执行。具体逻辑可以参考代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>WriteBatch<span style="color:#333">*</span> DBImpl<span style="color:#333">::</span>BuildBatchGroup(Writer<span style="color:#333">**</span> last_writer) {
</span></span><span style="display:flex;"><span>  mutex_.AssertHeld();
</span></span><span style="display:flex;"><span>  assert(<span style="color:#333">!</span>writers_.empty());
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 取出队首 writer
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Writer<span style="color:#333">*</span> first <span style="color:#333">=</span> writers_.front();
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 取出队首 writer 的待写数据集
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  WriteBatch<span style="color:#333">*</span> result <span style="color:#333">=</span> first<span style="color:#333">-&gt;</span>batch;
</span></span><span style="display:flex;"><span>  assert(result <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 计算队首 writer 数据集大小
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  size_t size <span style="color:#333">=</span> WriteBatchInternal<span style="color:#333">::</span>ByteSize(first<span style="color:#333">-&gt;</span>batch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// 虽然支持合并, 但是有两个限制条件:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#888">// 1. 不合并同步写入操作(设置了 writer.sync), 发现同步写操作立马停止后续合并操作并返回已合并内容.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#888">// 2. 为了避免小数据量写入操作被延迟太久, 针对合并上限做了限制, 最大 1MB.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  size_t max_size <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">&lt;&lt;</span> <span style="color:#00d;font-weight:bold">20</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#888">// 如果队首 writer 要写内容大小不超过 128KB
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (size <span style="color:#333">&lt;=</span> (<span style="color:#00d;font-weight:bold">128</span><span style="color:#333">&lt;&lt;</span><span style="color:#00d;font-weight:bold">10</span>)) {
</span></span><span style="display:flex;"><span>	<span style="color:#888">// 则 max_size 改为不超过 256KB
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    max_size <span style="color:#333">=</span> size <span style="color:#333">+</span> (<span style="color:#00d;font-weight:bold">128</span><span style="color:#333">&lt;&lt;</span><span style="color:#00d;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#333">*</span>last_writer <span style="color:#333">=</span> first;
</span></span><span style="display:flex;"><span>  std<span style="color:#333">::</span>deque<span style="color:#333">&lt;</span>Writer<span style="color:#333">*&gt;::</span>iterator iter <span style="color:#333">=</span> writers_.begin();
</span></span><span style="display:flex;"><span>  <span style="color:#333">++</span>iter;  <span style="color:#888">// Advance past &#34;first&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// iter 从 first 之后 writer 开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">for</span> (; iter <span style="color:#333">!=</span> writers_.end(); <span style="color:#333">++</span>iter) {
</span></span><span style="display:flex;"><span>    Writer<span style="color:#333">*</span> w <span style="color:#333">=</span> <span style="color:#333">*</span>iter;
</span></span><span style="display:flex;"><span>		<span style="color:#888">// 同步写操作不做合并
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (w<span style="color:#333">-&gt;</span>sync <span style="color:#333">&amp;&amp;</span> <span style="color:#333">!</span>first<span style="color:#333">-&gt;</span>sync) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Do not include a sync write into a batch handled by a non-sync write.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (w<span style="color:#333">-&gt;</span>batch <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>      size <span style="color:#333">+=</span> WriteBatchInternal<span style="color:#333">::</span>ByteSize(w<span style="color:#333">-&gt;</span>batch);
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (size <span style="color:#333">&gt;</span> max_size) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 避免 batch group 过大
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Append to *result
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (result <span style="color:#333">==</span> first<span style="color:#333">-&gt;</span>batch) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 不篡改 first writer 的 batch, 而是把若干 batch 合并到临时的 tmp_batch_ 中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        result <span style="color:#333">=</span> tmp_batch_;
</span></span><span style="display:flex;"><span>        assert(WriteBatchInternal<span style="color:#333">::</span>Count(result) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>        WriteBatchInternal<span style="color:#333">::</span>Append(result, first<span style="color:#333">-&gt;</span>batch);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      WriteBatchInternal<span style="color:#333">::</span>Append(result, w<span style="color:#333">-&gt;</span>batch);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888">// last_writer 指向被合并的最后一个 writer
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#333">*</span>last_writer <span style="color:#333">=</span> w;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简单来说，遍历待执行的WriteBatch，只要它</p>
<ol>
<li>不要求同步</li>
<li>合并后不会导致WriteBatch大小超过<code>max_size</code>。</li>
</ol>
<p>都会被合并，但只要违反上述任意一条，合并流程就会终止。</p>
<p>经过上述流程，我们完成了对写操作的所有预处理，可以进行真正的写操作了。</p>
<h2 id="log文件的格式与生成">log文件的格式与生成</h2>
<p>在生成了待写入的<code>WriteBatch</code>后,我们首先将其写入到<code>log文件</code>中。<code>log文件</code>的内部格式是通过block进行组织的，具体结构如下图所示。</p>
<div style="text-align: center">
<img src="/pic/levelDB/log-format.png"/>
</div>
<p>我们可以看到<code>log文件</code>是由一个个Block组成的，而每一个Block的大小都是固定的<code>32KB</code>，Block中存储着多个WriteBatch:头四个byte为校验和，后两个byte为data的长度，后续的一个byte为type(前七个byte被统称为<code>Header</code>)，最后剩下的就是data的数据，也就是WriteBatch中的<code>rep_</code>。</p>
<p>如果一个block剩余空间不足以存储<code>Header</code>，也就是他剩下的存储空间小于7byte,那么我们会对这个Block末尾填充0,然后将数据写到新的Block中。</p>
<p>现在我们来讲一下Header中的<code>type</code>代表着什么。考虑这么一种情况，如果block中的剩余空间太小，以致于我们的<code>WriteBatch</code>无法全部存储在该<code>Block</code>中，那么我们可能要将数据分为不同的块存储到不同的Block中，为了后续读的时候可以知道，这是不是一个完整的块，以及何时读完了完整的块。我们需要<code>type</code>来进行标识。</p>
<p><code>type</code>依旧为枚举类型.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">RecordType</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Zero is reserved for preallocated files
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  kZeroType <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kFullType <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// For fragments
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  kFirstType <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span>,
</span></span><span style="display:flex;"><span>  kMiddleType <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">3</span>,
</span></span><span style="display:flex;"><span>  kLastType <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">4</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>其中</p>
<ol>
<li>kFullType 表明后续的data数据为<strong>完整</strong>的数据</li>
<li>kFirstType 表明这是分块后的<strong>第一块</strong>数据，仍需要继续读取</li>
<li>kMiddleType表明这是分块后的<strong>中间</strong>数据，仍需要继续读取</li>
<li>kLastType 表明这是分块后的<strong>最后一块</strong>数据，无需读取。</li>
</ol>
<p>在将WriteBatch的数据写入到log文件后，我们就完成了写入的第一步，写日志。</p>
<h3 id="memtable的实现">MemTable的实现</h3>
<p>在将<code>writeBatch</code>写入到<code>log文件</code>后，我们便可以将数据写入<code>MemTable</code>中。</p>
<p>我们会对<code>writeBatch</code>中的<code>(tag,Key,value)</code>进行遍历，根据<code>tag</code>的不同，决定是向<code>MemTable</code>添加还是删除。</p>
<p>因为<code>MemTable</code>的内部实现是<strong>skiplist</strong>，而<strong>skiplist</strong>只能回答<strong>key</strong>在不在，而不能回答<strong>key</strong>关联的<strong>value</strong>是什么，因此我们需要将用户输入的<code>(key,value)</code>转化为<strong>skiplist</strong>中内部使用的<strong>key</strong>。</p>
<div style="text-align: center">
<img src="/pic/levelDB/internal-key.png"/>
</div>
<p>从图中可以发现，<code>key</code>和<code>value</code>中间被<code>(sequence number , tag)</code>隔开，这样的目的是为了后续在排序时，我们可以先按照<code>key</code>从小到大排序, 当<code>key</code>相同时，<code>(sequence number, tag)</code>按照由大到小排序，通过这种方式，永远是版本最新的在最前面（<code>(sequence number, tag)</code>越大，版本越新）。</p>
<p>最后就是向<code>MemTable</code>中插入该<code>internal key</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> Key, <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Comparator</span><span style="color:#333">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> SkipList<span style="color:#333">&lt;</span>Key,Comparator<span style="color:#333">&gt;::</span>Insert(<span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> key) {
</span></span><span style="display:flex;"><span>  <span style="color:#888">// pre 将用于存储 key 对应的各个索引层的前驱节点
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Node<span style="color:#333">*</span> prev[kMaxHeight];
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 找到第一个大与于目标 key 的节点, 一会会把 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 插到这个节点前面.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 如果为 nullptr 表示当前 SkipList 节点都比 key 小.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Node<span style="color:#333">*</span> x <span style="color:#333">=</span> FindGreaterOrEqual(key, prev); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 虽然 x 是我们找到的第一个大于等于目标 key 的节点, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 但是 leveldb 不允许重复插入 key 相等的数据项.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  assert(x <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span> <span style="color:#333">||</span> <span style="color:#333">!</span>Equal(key, x<span style="color:#333">-&gt;</span>key));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 确定待插入节点的最大索引层数
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">int</span> height <span style="color:#333">=</span> RandomHeight();
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 更新 SkipList 实例维护的最大索引层数
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (height <span style="color:#333">&gt;</span> GetMaxHeight()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果最大索引层数有变, 则当前节点将是索引层数最多的节点,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 需要将前面求得的待插入节点的前驱节点高度补齐.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> i <span style="color:#333">=</span> GetMaxHeight(); i <span style="color:#333">&lt;</span> height; i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 新生成了几个 level, key 对应的前驱节点肯定都是 dummy head
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      prev[i] <span style="color:#333">=</span> head_; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888">//fprintf(stderr, &#34;Change height from %d to %d\n&#34;, max_height_, height);
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 这里在修改 max_height_ 无需同步, 哪怕同时有多个并发读线程. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 其它并发读线程如果观察到新的 max_height_ 值, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 那它们将会要么看到 dummy head 新的索引层(注意 SkipList 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 初始化时会把 dummy head 的索引高度直接初始化为最大, 默认是 12, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 所以不存在越界问题)的值都为 nullptr, 要么看到的是
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 下面循环将要赋值的新节点 x. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    max_height_.NoBarrier_Store(<span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">void</span><span style="color:#333">*&gt;</span>(height));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 为待插入数据创建一个新节点
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  x <span style="color:#333">=</span> NewNode(key, height);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 将 x 插入到每一层前后节点之间, 注意是每一层, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 插入的时候都是先采用 no barrier 方式为 x 后继赋值, 此时 x 还不会被其它线程看到; 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 然后插入一个 barrier, 则上面 no barrier 的修改针对全部线程都可见了(其中也包括
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 了 NewNode 时可能发生的通过 NoBarrier_Store 方式修改的 arena_.memory_usage_), 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 最后修改 x 前驱的后继为自己. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> height; i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 注意该循环就下面两步, 而且只有第二步采用了同步设施, 尽管如此,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 第一步的写操作对其它线程也是可见的. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 这是 Release-Acquire ordering 语义所保证的. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    x<span style="color:#333">-&gt;</span>NoBarrier_SetNext(i, prev[i]<span style="color:#333">-&gt;</span>NoBarrier_Next(i));
</span></span><span style="display:flex;"><span>    prev[i]<span style="color:#333">-&gt;</span>SetNext(i, x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了可以读懂上面的代码，我们先来阐述一下<strong>LevelDB</strong>是如何实现<strong>skiplist</strong>的。</p>
<p>首先我们先看一下<code>SkipList::Node</code>的定义</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> Key, <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Comparator</span><span style="color:#333">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">SkipList</span><span style="color:#333">&lt;</span>Key,Comparator<span style="color:#333">&gt;::</span>Node {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">explicit</span> <span style="color:#06b;font-weight:bold">Node</span>(<span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> k) <span style="color:#333">:</span> key(k) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Key <span style="color:#080;font-weight:bold">const</span> key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node<span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">Next</span>(<span style="color:#339;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    assert(n <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Node<span style="color:#333">*&gt;</span>(next_[n].Acquire_Load());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">SetNext</span>(<span style="color:#339;font-weight:bold">int</span> n, Node<span style="color:#333">*</span> x) {
</span></span><span style="display:flex;"><span>    assert(n <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    next_[n].Release_Store(x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node<span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">NoBarrier_Next</span>(<span style="color:#339;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    assert(n <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Node<span style="color:#333">*&gt;</span>(next_[n].NoBarrier_Load());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">NoBarrier_SetNext</span>(<span style="color:#339;font-weight:bold">int</span> n, Node<span style="color:#333">*</span> x) {
</span></span><span style="display:flex;"><span>    assert(n <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    next_[n].NoBarrier_Store(x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#080;font-weight:bold">private</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Array of length equal to the node height. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// next_[0] is lowest level link.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  port<span style="color:#333">::</span>AtomicPointer next_[<span style="color:#00d;font-weight:bold">1</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>从代码中，我们看到<code>Node</code>有两个成员变量，一个是<code>key</code>，一个是<code>next_</code>，<code>key</code>没有什么好说的，主要需要理解的是<code>next_</code>,简单点来说，<code>next_</code>的长度等于Node的高度，<code>next_[i]</code>为<code>Node</code>在<code>level-i</code>的后继节点。通过下图，相信你可以更好理解。</p>
<div style="text-align: center">
<img src="/pic/levelDB/node.png"/>
</div>
<p>了解完<code>Node</code>后，我们还需要知道<code>SkipList::head_</code>,这个成员变量是一个dummy node,它的类型也是<code>Node</code>,它的<code>next_</code>点保存着每一个level的首节点。
因此插入的过程可以描述为</p>
<ol>
<li>找到第一个大与于目标 key 的节点, 一会会把 key插到这个节点前面,如果为 nullptr 表示当前 skipList 节点都比 key 小.同时会记录每一层刚好比key小的节点。</li>
<li>为该节点随机生成一个层数，作为该节点的最大层数。</li>
<li>通过之前找到的刚好比他大的节点，以及刚好比他小的节点，将该节点插入进skiplist.</li>
</ol>
<p>当将WriteBatch所有的<code>(key, value,tag)</code>，全部插入<code>MemTable</code>后，我们可以认为插入的过程已经全部完成了，剩下的就是将之前合并到新的WriteBatch的那些<code>Writer</code>移出队列，并唤醒队列的头部<code>Writer</code>,相信通过代码，可以很容易理解。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">while</span> (<span style="color:#007020">true</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// [&amp;w, last_writer] 的 batch 被合并写入 log 了, 所以将其出队.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    Writer<span style="color:#333">*</span> ready <span style="color:#333">=</span> writers_.front();
</span></span><span style="display:flex;"><span>    writers_.pop_front();
</span></span><span style="display:flex;"><span>    <span style="color:#888">// &amp;w 并没有 wait, 它是本次负责合并写入的 writer,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// 所以它 &amp;w 的 status 和 done 可以不用改, 反正也用不到.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (ready <span style="color:#333">!=</span> <span style="color:#333">&amp;</span>w) {
</span></span><span style="display:flex;"><span>			<span style="color:#888">// 传递合并写执行结果给 group 中各个 writer
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      ready<span style="color:#333">-&gt;</span>status <span style="color:#333">=</span> status;
</span></span><span style="display:flex;"><span>      ready<span style="color:#333">-&gt;</span>done <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 唤醒当前方法入口的 w.cv.Wait(), 通过此处被唤醒的
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>			<span style="color:#888">// writers 都是被合并到队首 writer 统一写入 log 文件的.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 它们被唤醒后, 只需检查下 done 状态就可以返回了.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      ready<span style="color:#333">-&gt;</span>cv.Signal();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888">// last_writer 指向被合并处理的最后一个 writer
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (ready <span style="color:#333">==</span> last_writer) <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 如果当前 writers_ 队列不为空, 唤醒当前的队首节点.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>writers_.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 叫醒新的待写入 writer
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    writers_.front()<span style="color:#333">-&gt;</span>cv.Signal();
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="ldb文件的格式与生成">ldb文件的格式与生成</h3>
<p>当把WriteBatch所有的<code>(key, value,tag)</code>，全部插入<code>MemTable</code>后，<code>Put</code>流程就算结束了。 ldb文件的格式与生成，应当属于compact中的内容。但是趁现在对<code>MemTable</code>的记性还比较新，可以顺便将<code>ldb文件</code>一起讲了。而且<code>ldb文件</code>本质上就是将<code>MemTable</code>落盘，内容上也不算突兀。</p>
<p>ldb文件由五部分组成</p>
<ol>
<li>data blocks</li>
<li>filter blcoks</li>
<li>filterindex block</li>
<li>index block</li>
<li>footer</li>
</ol>
<p>其中<code>data blocks</code>中保存着KV数据，<code>filter blocks</code>中存储着布隆过滤器，<code>filterindex block</code>存储着指向<code>filter blocks</code>的索引，<code>index block</code>存储着指向<code>data blocks</code>的索引，<code>footer</code>存储着指向<code>filterindex block</code>和<code>index block</code>的索引。</p>
<p>我们先看一下组成<code>data block</code>以及<code>index block</code>的基础组成部分。</p>
<div style="text-align: center">
<img src="/pic/levelDB/block-layout.png"/>
</div>
<p>因为<code>data block</code>和<code>index block</code>都是由KV组成，<code>data block</code>的Key是skipList的<code>internal key</code>, Value是用户输入的<code>Value</code>.<code>index block</code>的Key是每个<code>data block</code>的最后一个Key, Value是<code>data block</code>的<code>handle</code>.</p>
<p>我们可以详细看一下这个Block的结构组成,因为我们的Key是按照顺序的,因此我们可以使用仅存储两个Key不同的部分,从而减少空间占用,因此我们先存储两个Key相同的长度大小,需要存储的Key的大小,Value的长度大小,存储的Key的内容,存储的Value内容.我们可以通过下面的例子更好的阐述一下这个概念</p>
<div style="text-align: center">
<img src="/pic/levelDB/block-demo.png"/>
</div>
<p>如图所示,因为<code>hello</code>以及<code>hellz</code>共享<code>hell</code>,因此对于<code>hellz</code>我们仅需要存储z即可.</p>
<p>每个 block 的前缀压缩不是从第一个数据项开始就一直下去, 而是每隔一段(间隔可配置)设置一个新的前缀压缩起点(作为新起点的数据项的 key 保存原值而非做前缀压缩), <code>restart</code>指的就是新起点, 从这个地方开始继续做前缀压缩.在写入文件前,我们还需要对KV对以及restart数据一起进行压缩,压缩的方式由<code>compress type</code>表示,</p>
<p>因此单个<code>Block</code>由<code>KV对</code>, <code>restart数组</code>,<code>restart数组长度</code>,<code>压缩类型</code>,<code>CRC校验和</code>组成.而<code>data block</code>以及<code>index block</code>则是由一个个<code>Block</code>组成.</p>
<p>而<code>filter block</code>则是根据<code>data block</code>的大小生成布隆过滤器,默认每2K个大小生成一个布隆过滤器.它的存储结构为</p>
<div style="text-align: center">
<img src="/pic/levelDB/filter-block.png"/>
</div>
<p>开始存着一系列的布隆过滤器,然后是各个布隆过滤器的offset数组,紧跟着offset的offset(通过该值找到offset,因为offset是数组是一个变值),最后跟的是这个<code>filter block</code>的元信息(<code>data block</code>数据多大后产生一个布隆过滤器)</p>
<p>而<code>filter index block</code>则使用<code>Block</code>的存储格式存储着<strong>Key: &ldquo;filter.${filter.name}&rdquo;, Value: offset and size of filter block</strong></p>
<p>最后的<code>Footer</code>的格式则为下图所示.</p>
<div style="text-align: center">
<img src="/pic/levelDB/footer.png"/>
</div>
<p><code>Footer</code>中存储着<code>filter index block</code>的指针以及<code>index block</code>的指针以及<code>magic number</code></p>
<p>在介绍完各个模块的磁盘结构后,我们可以看一下ldb文件的全貌,以及各部分之间的关系,如下图所示.</p>
<div style="text-align: center">
<img src="/pic/levelDB/ldb-overview.png"/>
</div>
<p>在了解了整个全貌后,我们可以看一下整个生成的流程是怎么样的.</p>
<ol>
<li>首先构建出一个新的<code>TableBuilder</code>, 然后按序将<code>Memtable</code>中的数据写入<code>TableBuilder</code>.</li>
<li><code>TableBuilder</code>将数据全部写入<code>data block</code>中 <strong>(按照Block的格式写)</strong></li>
<li>当Block的大小超过4K时,将生成的<code>data block</code>落盘,<strong>尝试</strong>生成一个<code>filter block</code>,并生成一个<code>index handle</code>,将其插入到<code>index block</code>中.(注意,这里插入index block前,会尝试缩短key的大小,详情请参考代码<code>Comparator::FindShortestSeparator</code>).</li>
</ol>
<p>最后等所有数据添加完后,依次写入<code>data block</code>, <code>filter block</code>, <code>filter index block</code>, <code>index block</code>,以及<code>footer</code></p>
<h3 id="overview-1">Overview</h3>
<p>本文介绍了LevelDB的写操作的流程，以及相关文件的生成与格式。这篇文章并没有将所有的细节都写出来，如果你想要详细了解，我推荐你还是需要去读相关代码。这篇文章更侧重描写出LevelDB的大概轮廓，以及一些比较重要的细节。希望对你理解LevelDB相关代码有所帮助。</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/database/">database</a>
<a href="/categories/leveldb/">leveldb</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
