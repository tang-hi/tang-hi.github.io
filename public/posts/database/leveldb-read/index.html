<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>LevelDB(2) -- 读 | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的读操作，以及相应的迭代器.">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="LevelDB(2) -- 读" />
<meta property="og:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的读操作，以及相应的迭代器." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/database/leveldb-read/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-19T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="LevelDB(2) -- 读"/>
<meta name="twitter:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的读操作，以及相应的迭代器."/>

<meta itemprop="name" content="LevelDB(2) -- 读">
<meta itemprop="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的读操作，以及相应的迭代器."><meta itemprop="datePublished" content="2023-06-19T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-06-19T00:00:00+00:00" />
<meta itemprop="wordCount" content="1289">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">19</span>
<span class="rest">Jun 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">LevelDB(2) -- 读</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;7&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;1289&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>本文将介绍LevelDB的读操作，以及相应的迭代器</p>
<h2 id="overview">Overview</h2>
<p>我们先看一下levelDB读操作的整体流程。</p>
<div style="text-align: center">
<img src="/pic/levelDB/read-overview.png"/>
</div>
<p>我们首先会尝试从<code>MemTable</code>中读取对应的KV，如果没获取到，我们会从<code>ImmutableMemTable</code>中读取，如果仍旧没读到，我们就会尝试去<code>${version}.ldb</code>中获取对应的KV。</p>
<p>因为<code>MemTable</code>与<code>ImmutableMemTable</code>的结构完全一致，他们的区别仅仅是一个是目前正在使用的<code>MemTable</code>,一个是已经达到<code>Flush</code>的阈值，准备往磁盘中写了。因此这篇文章会分为两部分来介绍</p>
<ol>
<li>从<code>Memtable</code>中读取KV。</li>
<li>从<code>${version}.ldb</code>中读取KV。</li>
</ol>
<h2 id="read-from-memtable">Read From Memtable</h2>
<p>还记得我们在 <a href="../leveldb-write/">LevelDB(1) – 写</a>中对于<code>Memtable的</code>描述,它会将用户输入的Key转化为<strong>InternalKey</strong>再插入，因此为了查询的时候，Key保持一致。我们也需要先将Key转化为InternalKey。</p>
<div style="text-align: center">
<img src="/pic/levelDB/internal-key.png"/>
</div>
<p>在这里<code>sequence number</code>为最大值（这样我们才能获取最新的数据），如果用户有指定<code>snapshot</code>。那么这个<code>sequence number</code>则为该<code>snapshot</code>的值。tag则为<code>kValueTypeForSeek</code>* ,因为我们排序数据项时会考虑序列号, 而且会在 user_key 部分相等时按照 tag (由七个字节序列号后跟一个字节 ValueType 构成)降序排列(<strong>tag 越大 internal_key 越小</strong>), 所以我们应该使用<strong>最大</strong>的 ValueType,这样调用 MemTable.Seek(k) 确保找到的第一个大于等于 k 的数据项(<code>MemTable</code> 中数据项从小到大排序)就是我们要找的数据项.</p>
<p>在完成InternalKey的构造后，我们开始在<code>Memtable</code>中查询数据。<code>Memtable</code>的整个查询接口都是由迭代器暴露出来的，因此我们先看一下迭代器的接口。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Iterator</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#080;font-weight:bold">public</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Initialize an iterator over the specified list.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// The returned iterator is not valid.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 构造方法返回的迭代器是无效的
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">explicit</span> Iterator(<span style="color:#080;font-weight:bold">const</span> SkipList<span style="color:#333">*</span> list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Returns true iff the iterator is positioned at a valid node.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 当且仅当迭代器指向有效的 node 时才返回 true. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">Valid</span>() <span style="color:#080;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Returns the key at the current position.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// REQUIRES: Valid()
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 返回迭代器当前位置的 key. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 要求: 当前迭代器有效. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> key() <span style="color:#080;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Advances to the next position.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// REQUIRES: Valid()
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将迭代器移动到下个位置. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 要求: 当前迭代器有效. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Next</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Advances to the previous position.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// REQUIRES: Valid()
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将迭代器倒退一个位置. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 要求: 当前迭代器有效. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Prev</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Advance to the first entry with a key &gt;= target
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将迭代器移动到第一个 key &gt;= target 的数据项所在位置. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Seek</span>(<span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Position at the first entry in list.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// Final state of iterator is Valid() iff list is not empty.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将迭代器移动到 skiplist 第一个数据项所在位置. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 迭代器的最终状态是有效的, 当且仅当 skiplist 不为空. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">SeekToFirst</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Position at the last entry in list.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// Final state of iterator is Valid() iff list is not empty.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将迭代器移动到 skiplist 最后一个数据项所在位置. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 迭代器的最终状态是有效的, 当且仅当 skiplist 不为空. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">SeekToLast</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#080;font-weight:bold">private</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">const</span> SkipList<span style="color:#333">*</span> list_;
</span></span><span style="display:flex;"><span>    Node<span style="color:#333">*</span> node_;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Intentionally copyable
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  };
</span></span></code></pre></div><p>这里面我们主要关注<code>Seek</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> Key, <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Comparator</span><span style="color:#333">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">inline</span> <span style="color:#339;font-weight:bold">void</span> SkipList<span style="color:#333">&lt;</span>Key,Comparator<span style="color:#333">&gt;::</span>Iterator<span style="color:#333">::</span>Seek(<span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> target) {
</span></span><span style="display:flex;"><span>  node_ <span style="color:#333">=</span> list_<span style="color:#333">-&gt;</span>FindGreaterOrEqual(target, <span style="color:#080;font-weight:bold">nullptr</span>); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到里面实际使用的还是<code>SkipList::FindFreaterOrEqual</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> Key, <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Comparator</span><span style="color:#333">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">typename</span> SkipList<span style="color:#333">&lt;</span>Key,Comparator<span style="color:#333">&gt;::</span>Node<span style="color:#333">*</span> 
</span></span><span style="display:flex;"><span>SkipList<span style="color:#333">&lt;</span>Key,Comparator<span style="color:#333">&gt;::</span>FindGreaterOrEqual(<span style="color:#080;font-weight:bold">const</span> Key<span style="color:#333">&amp;</span> key, Node<span style="color:#333">**</span> prev)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#888">// head_ 为 SkipList 原始数据链表的起始节点,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 该节点不存储用户数据, 仅用作哨兵.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Node<span style="color:#333">*</span> x <span style="color:#333">=</span> head_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 每次查找都是从最高索引层开始查找, 只要确认可能存在
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 才会降到下一级更细致索引层继续查找.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 索引层计数从 0 开始, 所以这里减一才是最高层.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">int</span> level <span style="color:#333">=</span> GetMaxHeight() <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>; 
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">while</span> (<span style="color:#007020">true</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 下面用的 Next 方法是带同步设施的, 其实由于 SkipList 对外开放的操作
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 需要调用者自己提供同步, 所以这里可以直接用 NoBarrier_Next.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    Node<span style="color:#333">*</span> next <span style="color:#333">=</span> x<span style="color:#333">-&gt;</span>Next(level);
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (KeyIsAfterNode(key, next)) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// key 大于 next, 在该索引层继续向后找
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      x <span style="color:#333">=</span> next; 
</span></span><span style="display:flex;"><span>    } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// key 可能存在.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 如果 key 比 SkipList 中每个 node 的 key 都小, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 那么最后返回的 node 为 head_-&gt;Next(0), 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 同时 pre 里面存的都是 dummy head; 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 调用者需要使用返回的 node 与自己持有 key进一步进行对比,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 以确定是否找到目标节点. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (prev <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) prev[level] <span style="color:#333">=</span> x;
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (level <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 就是它！如果 key 比 SkipList 里每个 node 的都大, 则 next 最终为 nullptr.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">return</span> next;  
</span></span><span style="display:flex;"><span>      } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 确定目标范围, 但是粒度太粗, 下沉一层继续找
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        level<span style="color:#333">--</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码写的十分简单易懂，从最高层开始寻找，如果<code>Key</code>大于当前节点，那么往后继续找，否则下沉一层继续找，如果已经是最后一层了，那么返回该节点。</p>
<p>在找到节点后，我们根据<strong>InternalKey</strong>的格式将用户输入的key解析出来进行比较，如果不相等，那么返回未找到，如果相等说明我们查到了这个key的最新值，我们查看该节点的<code>tag</code>是<code>kTypeValue</code> 还是<code>kTypeDeletion</code>？如果是<code>kTypeValue</code>，那么我们找到了那个值，但如果是<code>kTypeDeletion</code>则说明该值已经被删除。</p>
<p>可以看到从<code>Memtable</code>中查询数据还相对较为简单，只要明白<strong>InternalKey</strong>的排列顺序即可。</p>
<h2 id="read-from-ldb-file">Read From LDB FILE</h2>
<p>如果从<code>Memtable</code>中无法找到对应的KV,那么我们就需要从文件中进行查找了。
这里我们分为两种情况，Level-0的的文件查找以及Level-1以上的文件查找。之所以要这么区分是因为Level-0各个文件的key可能重叠,例如<strong>file1</strong>的range为[0,100],<strong>file2</strong>的range为[50,200]。而level-1及以上的文件的key则不重叠，也就是不相交，因此我们会采用不同的方式来进行读取。查找的过程先从Level-0开始，而后逐级向上。这是因为Level越低，数据越新，如果我们得到了最新的数据，就不用再往下面找了。</p>
<h3 id="1-确定需要读取的文件">1. 确定需要读取的文件</h3>
<p>首先要做的就是要确定哪些文件。从下图中我们可以看到，对于Level-0以及其他Level，确定要读取的文件是不一样的。</p>
<div style="text-align: center">
<img src="/pic/levelDB/determin-file.png"/>
</div>
<p>因为Level-0中的文件key之间可能有重叠，因此我们需要一个个进行检查，而对于Level-x(x&gt;1)来说，每个文件不相交，因此我们可以对他们按key排序后，进行二分查找，从而加快查找的速度。</p>
<h3 id="2-读取ldb文件查找kv">2. 读取ldb文件，查找KV</h3>
<p>在确定了读取的文件后，我们需要读取相应的文件，并检查需要查询的<code>KEY</code>是否在<code>ldb</code>文件中。</p>
<p>为了读取文件，我们会先尝试从<code>TableCache</code>中找到需要的文件Cache，如果没找到，我们再去磁盘中读取并反序列化为<code>Table</code>,将反序列化的<code>Table</code>插入到<code>TableCache</code>中。</p>
<h4 id="21-tablecache的实现">2.1 TableCache的实现</h4>
<p>目前<code>LevelDB</code>使用的缓存策略为LRU，我们先看一下Cache的接口。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">LEVELDB_EXPORT</span> Cache {
</span></span><span style="display:flex;"><span> <span style="color:#080;font-weight:bold">public</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>  Cache() <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Cache(<span style="color:#080;font-weight:bold">const</span> Cache<span style="color:#333">&amp;</span>) <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>  Cache<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">=</span>(<span style="color:#080;font-weight:bold">const</span> Cache<span style="color:#333">&amp;</span>) <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 析构时调用构造时传入的 deleter 函数销毁每一个数据项. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#333">~</span>Cache();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Cache 中存储的数据项的抽象类型, 具体实现参见 LRUHandle
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Handle</span> { };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 插入一对 &lt;key, value&gt; 到 cache 中, 同时为这个映射设置
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 一个对 cache 容量的消耗, 具体使用时候用的是要插入的数据
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 字节数. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 该方法返回一个 handle, 对应本次插入的映射. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 当调用者不再需要这个映射的时候, 需要调用 this-&gt;Release(handle). 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 当被插入的数据项不再被需要时, key 和 value 将会被传递给这里指定的 deleter. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param key 要插入的映射的 key
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param value 要插入的映射的 value
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param charge 要插入的映射对应的花费
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param deleter 要插入的映射对应的 deleter
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @return 要插入的映射对应的 handle
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> Handle<span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">Insert</span>(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value, size_t charge,
</span></span><span style="display:flex;"><span>                         <span style="color:#339;font-weight:bold">void</span> (<span style="color:#333">*</span>deleter)(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 如果 cache 中没有针对 key 的映射, 返回 nullptr. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 其它情况返回对应该映射的 handle. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 当不再需要这个映射的时候, 调用者必须调用 this-&gt;Release(handle). 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param key 要查询映射的 key
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @return 要查询的映射对应的 handle
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> Handle<span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">Lookup</span>(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 先通过 Lookup 查询映射对应的 handle, 然后调用该函数来释放该映射. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 前提一: handle 之前未被释放过.
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 前提二: handle 必须是通过在 *this 上调用某个方法返回的.
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param handle 通过 Lookup 查询到的映射对应的 handle
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Release</span>(Handle<span style="color:#333">*</span> handle) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 成功调用 Lookup 后返回的 handle 中封装的 value 可以通过该方法解析. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 前提一: handle 之前未被释放过
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 前提二: handle 必须是通过在 *this 上调用某个方法返回的
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param handle
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @return
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">Value</span>(Handle<span style="color:#333">*</span> handle) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 如果 cache 包含了 key 对应的映射, 删除之. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 注意, 底层的数据项将会继续存在直到现有的指向该数据项的全部 handles 已被释放掉. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @param key 要删除的映射对应的 key
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Erase</span>(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 返回一个新生成的数字 id. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 可能会被共享同一个 cache 的多个客户端用来对键空间进行分区.
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 典型地用法是, 某个客户端在启动时调用该方法生成一个新 id, 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 然后将该 id 作为它的 keys 的前缀. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @return
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#339;font-weight:bold">uint64_t</span> <span style="color:#06b;font-weight:bold">NewId</span>() <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 移除 cache 中全部不再活跃的数据项. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 内存受限的应用可以调用该方法来减少缓存造成的内存消耗. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   *
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 该方法的默认实现什么也不做, 强烈建议在派生类实现中重写该方法. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * leveldb 未来版本可能会将该方法修改为一个纯抽象方法. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Prune</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * 返回 cache 为了存储当前全部元素的总花费的估计值
</span></span></span><span style="display:flex;"><span><span style="color:#888">   * @return
</span></span></span><span style="display:flex;"><span><span style="color:#888">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">virtual</span> size_t <span style="color:#06b;font-weight:bold">TotalCharge</span>() <span style="color:#080;font-weight:bold">const</span> <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#080;font-weight:bold">private</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> LRU_Remove(Handle<span style="color:#333">*</span> e);
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">LRU_Append</span>(Handle<span style="color:#333">*</span> e);
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Unref</span>(Handle<span style="color:#333">*</span> e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Rep</span>;
</span></span><span style="display:flex;"><span>  Rep<span style="color:#333">*</span> rep_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>对于Cache接口的实现则为<code>ShardedLRUCache</code>，它维护了多个cache shard，从而在并发访问时，无须使用一把大锁，而是可以更加细粒度的加锁，从而提升并发时的性能。</p>
<p>我们看一下<code>ShardedLRUCache::Insert</code>的实现</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">virtual</span> Handle<span style="color:#333">*</span> <span style="color:#06b;font-weight:bold">Insert</span>(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value, size_t charge,
</span></span><span style="display:flex;"><span>                         <span style="color:#339;font-weight:bold">void</span> (<span style="color:#333">*</span>deleter)(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value)) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 计算 hash
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">uint32_t</span> hash <span style="color:#333">=</span> HashSlice(key);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 基于 hash 做 sharding
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从代码中，我们可以看到<code>ShardedLRUCache</code>只计算key所属的shard，然后具体的逻辑由<code>LRUCache</code>执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#888">/**
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * 该方法类似 Cache::Insert() 不过多了一个 hash 参数.
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * 该方法线程安全, 允许多个线程并发向同一个 shard 中插入.
</span></span></span><span style="display:flex;"><span><span style="color:#888"> *
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @param key 要插入的数据项的 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @param hash 要插入的数据项的 hash
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @param value 要插入的数据项的 value
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @param charge 要插入的数据项的 charge
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @param deleter 要插入的数据项的 deleter
</span></span></span><span style="display:flex;"><span><span style="color:#888"> * @return 返回插入的数据项的句柄
</span></span></span><span style="display:flex;"><span><span style="color:#888"> */</span>
</span></span><span style="display:flex;"><span>Cache<span style="color:#333">::</span>Handle<span style="color:#333">*</span> LRUCache<span style="color:#333">::</span>Insert(
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">uint32_t</span> hash, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value, size_t charge,
</span></span><span style="display:flex;"><span>    <span style="color:#339;font-weight:bold">void</span> (<span style="color:#333">*</span>deleter)(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> value)) {
</span></span><span style="display:flex;"><span>  MutexLock <span style="color:#06b;font-weight:bold">l</span>(<span style="color:#333">&amp;</span>mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 基于 LRUHandle 本身大小和 key 的实际长度来分配空间. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 减掉的 1 指的是 LRUHandle 初始化时为 key_data 预占的空间, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 不减掉的话后面加上 key.size() 就多了一个字节. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  LRUHandle<span style="color:#333">*</span> e <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>LRUHandle<span style="color:#333">*&gt;</span>(
</span></span><span style="display:flex;"><span>      malloc(<span style="color:#080;font-weight:bold">sizeof</span>(LRUHandle)<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">+</span> key.size()));
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>value <span style="color:#333">=</span> value;
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>deleter <span style="color:#333">=</span> deleter;
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>charge <span style="color:#333">=</span> charge;
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>key_length <span style="color:#333">=</span> key.size();
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>hash <span style="color:#333">=</span> hash;
</span></span><span style="display:flex;"><span>  e<span style="color:#333">-&gt;</span>in_cache <span style="color:#333">=</span> <span style="color:#007020">false</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 能存在于 cache 中的最小 ref 值, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 表示当前除了 cache 对象还没有任何外部引用.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  e<span style="color:#333">-&gt;</span>refs <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>;  
</span></span><span style="display:flex;"><span>  memcpy(e<span style="color:#333">-&gt;</span>key_data, key.data(), key.size());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (capacity_ <span style="color:#333">&gt;</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 放入 in_use_ 列表就要增加引用.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    e<span style="color:#333">-&gt;</span>refs<span style="color:#333">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 该数据项被放到了 shard 中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    e<span style="color:#333">-&gt;</span>in_cache <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 将该数据项追加到 shard 的 in_use 链表
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    LRU_Append(<span style="color:#333">&amp;</span>in_use_, e);
</span></span><span style="display:flex;"><span>    usage_ <span style="color:#333">+=</span> charge;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 将数据项插入到 hashtable, 这可以看做一个二级缓存.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 如果 shard 中存在与 e &#34;相同的 key 相同的 hash&#34; 的项, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 则将 e 插入同时将老的数据项从 shard 彻底删除.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    FinishErase(table_.Insert(e));
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果 capacity_&lt;= 0 意味着关闭了缓存功能. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 此处的赋值是防止 key() 方法的 assert 失败. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    e<span style="color:#333">-&gt;</span>next <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>	<span style="color:#888">// 下面这个循环解释了 LRUCache 的 LRU 效果.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 如果本 shard 的使用量大于容量并且 lru 链表不为空, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 则从 lru 链表里面淘汰数据项, lru 链表数据当前肯定未被使用, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 直至使用量小于容量或者 lru 清空. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">while</span> (usage_ <span style="color:#333">&gt;</span> capacity_ <span style="color:#333">&amp;&amp;</span> lru_.next <span style="color:#333">!=</span> <span style="color:#333">&amp;</span>lru_) {
</span></span><span style="display:flex;"><span>		<span style="color:#888">// 这很重要, lru_.next 是 least recently used 的元素
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    LRUHandle<span style="color:#333">*</span> old <span style="color:#333">=</span> lru_.next;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// lru 链表里面的数据项除了被该 shard 引用不会被任何客户端引用
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    assert(old<span style="color:#333">-&gt;</span>refs <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 从 shard 将 old 彻底删除
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">bool</span> erased <span style="color:#333">=</span> FinishErase(table_.Remove(old<span style="color:#333">-&gt;</span>key(), old<span style="color:#333">-&gt;</span>hash));
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>erased) {  
</span></span><span style="display:flex;"><span>      <span style="color:#888">// to avoid unused variable when compiled NDEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      assert(erased);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 将 LRUHandle 重新解释为 Cache::Handle
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Cache<span style="color:#333">::</span>Handle<span style="color:#333">*&gt;</span>(e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们首先会malloc一个新的<code>LRUHandle</code>,然后对该<code>LRUHandle</code>进行赋值。随后我们直接使用头插法将这个<code>LRUHandle</code>插入链表中，并且如果这个key之前缓存过，那么我们将旧缓存删除，最后如果发现使用量超过限额，就尝试去除过期的数据。</p>
<p>我们再看看查找的代码，可以发现代码相当简单，通过key去<code>hashtable</code>中找到对应的<code>LRUHandle</code>并返回。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>Cache<span style="color:#333">::</span>Handle<span style="color:#333">*</span> LRUCache<span style="color:#333">::</span>Lookup(<span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> key, <span style="color:#339;font-weight:bold">uint32_t</span> hash) {
</span></span><span style="display:flex;"><span>  MutexLock <span style="color:#06b;font-weight:bold">l</span>(<span style="color:#333">&amp;</span>mutex_);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// table_ 是个哈希表, 存储了该 shard 全部数据项的指针, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// O(1) 复杂度. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  LRUHandle<span style="color:#333">*</span> e <span style="color:#333">=</span> table_.Lookup(key, hash); 
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (e <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果查到, 则将该数据项引用数加 1, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 查询命中后续就要. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    Ref(e); 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Cache<span style="color:#333">::</span>Handle<span style="color:#333">*&gt;</span>(e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="22-ldb的反序列化与查找">2.2 LDB的反序列化与查找</h4>
<p>反序列化LDB文件的入口函数为<code>Table::Open</code>, 我们配合着LDB的<code>Layout</code>来理解LDB的反序列化。</p>
<div style="text-align: center">
<img src="/pic/levelDB/ldb-overview.png"/>
</div>
<p>我们首先读取<code>Footer</code>获得<code>index Block</code>,<code>filter index block</code>的位置和大小，随后我们通过<code>index block</code>的位置和大小解析出<code>index Block</code>的内容（这里我们仅仅只是通过CRC检查文件完整性，及其根据compress type来解压文件，并不做更进一步的解析),然后我们再根据<code>filter index block</code>解析出<code>filter block</code>(这里我们会将<code>filter block</code>的<code>base</code>, <code>offset</code>, <code>bloom value</code>全部解析出来)。注意，我们并不会解析<code>data block</code>.</p>
<p>到了这里，我们就算将<code>ldb</code>文件反序列化为<code>Table</code>了。下面我们看一下查找的过程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#888">// 在 table 中查找 k 对应的数据项. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 如果 table 具有 filter, 则用 filter 找; 
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 如果没有 filter 则去 data block 里面查找, 
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 并且在找到后通过 saver 保存 key/value. 
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 注意, 针对 data block 的读取和解析发生在这个方法里.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Status Table<span style="color:#333">::</span>InternalGet(<span style="color:#080;font-weight:bold">const</span> ReadOptions<span style="color:#333">&amp;</span> options, <span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span> k,
</span></span><span style="display:flex;"><span>                          <span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span> arg,
</span></span><span style="display:flex;"><span>                          <span style="color:#339;font-weight:bold">void</span> (<span style="color:#333">*</span>saver)(<span style="color:#339;font-weight:bold">void</span><span style="color:#333">*</span>, <span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span>, <span style="color:#080;font-weight:bold">const</span> Slice<span style="color:#333">&amp;</span>)) {
</span></span><span style="display:flex;"><span>  Status s;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 针对 data index block 构造 iterator
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Iterator<span style="color:#333">*</span> iiter <span style="color:#333">=</span> rep_<span style="color:#333">-&gt;</span>index_block<span style="color:#333">-&gt;</span>NewIterator(rep_<span style="color:#333">-&gt;</span>options.comparator);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 在 data index block 中寻找第一个大于等于 k 的数据项, 这个数据项
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 就是目标 data block 的 handle.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  iiter<span style="color:#333">-&gt;</span>Seek(k);
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (iiter<span style="color:#333">-&gt;</span>Valid()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 取出对应的 data block 的 BlockHandle
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    Slice handle_value <span style="color:#333">=</span> iiter<span style="color:#333">-&gt;</span>value(); 
</span></span><span style="display:flex;"><span>    FilterBlockReader<span style="color:#333">*</span> filter <span style="color:#333">=</span> rep_<span style="color:#333">-&gt;</span>filter;
</span></span><span style="display:flex;"><span>    BlockHandle handle;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果有 filter 找起来就快了, 如果确定
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 不存在就可以直接反悔了.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (filter <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span> <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        handle.DecodeFrom(<span style="color:#333">&amp;</span>handle_value).ok() <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#333">!</span>filter<span style="color:#333">-&gt;</span>KeyMayMatch(handle.offset(), k)) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 没在该 data block 对应的过滤器找到这个 key, 肯定不存在
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    } <span style="color:#080;font-weight:bold">else</span> { 
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 如果没有 filter, 或者在 filter 中查询时无法笃定
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// key 不存在, 就需要在 block 中进行查找.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 看到了没? Open() 方法没有解析任何 data block, 解析
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 是在这里进行的, 因为这里要查询数据了.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      Iterator<span style="color:#333">*</span> block_iter <span style="color:#333">=</span> BlockReader(<span style="color:#080;font-weight:bold">this</span>, options, iiter<span style="color:#333">-&gt;</span>value());
</span></span><span style="display:flex;"><span>      block_iter<span style="color:#333">-&gt;</span>Seek(k);
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (block_iter<span style="color:#333">-&gt;</span>Valid()) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 将找到的 key/value 保存到输出型参数 arg 中, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 因为后面会将迭代器释放掉.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        (<span style="color:#333">*</span>saver)(arg, block_iter<span style="color:#333">-&gt;</span>key(), block_iter<span style="color:#333">-&gt;</span>value()); 
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      s <span style="color:#333">=</span> block_iter<span style="color:#333">-&gt;</span>status();
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">delete</span> block_iter;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (s.ok()) {
</span></span><span style="display:flex;"><span>    s <span style="color:#333">=</span> iiter<span style="color:#333">-&gt;</span>status();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">delete</span> iiter;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们首先会在<code>index block</code>中寻找刚好大于等于<code>k</code>的数据项，从而可以快速定位到<code>data block</code>,当然在往<code>data block</code>中查找前，我们可以先使用布隆过滤器来确定该值是否在这个<code>data block</code> 中,如果说在的话，我们就可以直接在<code>data block</code>中进行查找，并返回查找结果。</p>
<h3 id="overview-1">Overview</h3>
<p>本文介绍了LevelDB的读操作的流程。这篇文章并没有将所有的细节都写出来，如果你想要详细了解，我推荐你还是需要去读相关代码。这篇文章更侧重描写出LevelDB的大概轮廓，以及一些比较重要的细节。希望对你理解LevelDB相关代码有所帮助。</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/database/">database</a>
<a href="/categories/leveldb/">leveldb</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
