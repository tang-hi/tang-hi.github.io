<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>DuckDB --  ART索引 | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="DuckDB 是一款开源 OLAP 数据库。与 SQLite 类似，本文将介绍DuckDB内部所使用的索引结构">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="DuckDB --  ART索引" />
<meta property="og:description" content="DuckDB 是一款开源 OLAP 数据库。与 SQLite 类似，本文将介绍DuckDB内部所使用的索引结构" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/database/duckdb-index/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-21T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="DuckDB --  ART索引"/>
<meta name="twitter:description" content="DuckDB 是一款开源 OLAP 数据库。与 SQLite 类似，本文将介绍DuckDB内部所使用的索引结构"/>

<meta itemprop="name" content="DuckDB --  ART索引">
<meta itemprop="description" content="DuckDB 是一款开源 OLAP 数据库。与 SQLite 类似，本文将介绍DuckDB内部所使用的索引结构"><meta itemprop="datePublished" content="2023-07-21T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-07-21T00:00:00+00:00" />
<meta itemprop="wordCount" content="995">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">21</span>
<span class="rest">Jul 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">DuckDB --  ART索引</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;5&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;995&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>DuckDB不同于其他的数据库，并没有使用B+树作为主要索引结构，而是使用了ART(Adaptive Radix Tree)作为它内部的主要索引结构。本文将介绍这一索引</p>
<h2 id="artadaptive-radix-tree">ART(Adaptive Radix Tree)</h2>
<p><a href="https://db.in.tum.de/~leis/papers/ART.pdf" target="_blank">ART</a> 索引是由Viktor Leis, Alfons Kemper, Thomas Neumann等人提出，它相比于B+数的主要区别在于B+树是面向磁盘的，而ART则是面向内存的。即ART索引是需要全部加载到内存中的。DuckDB之所以选择这个索引有以下几方面的考虑</p>
<ol>
<li>随着内存越来越大，并且价格也越来越便宜，我们可以使用纯内存的索引，从而避免磁盘IO，提升性能。</li>
<li>ART索引可以很大程度上的节省空间。</li>
<li>ART索引支持范围查询。</li>
<li>ART索引有着较高的性能。</li>
</ol>
<p>后续本文会先介绍ART这一数据结构，然后配合着DuckDB的代码描述ART是如何实现的。</p>
<h2 id="数据结构">数据结构</h2>
<p>在讲ART索引之前，我们先看一下Trie树。(如果你不知道Trie树，可以参考<a href="https://en.wikipedia.org/wiki/Trie#:~:text=A%20prefix%20trie%20is%20an,of%20words%20with%20common%20prefixes." target="_blank">Trie</a> )</p>
<div style="text-align: center">
<img src="/pic/duckdb/trie.png"/>
</div>
<p>我们可以看到Trie树在检索时的优点是，它的检索时间仅与最长的字符串长度有关，而与存储的字符数量无关，这一特性在数据量极大的情况下十分优秀。但是它的缺点是浪费空间，即每个内部节点都需要保存<strong>固定数量</strong>的指针，即使它仅有极少的子结点。</p>
<p>比如图中的root节点，尽管他只有三个子结点，但是它仍然需要保存指向<code>a,c,e...</code>的空指针。这十分浪费空间。其次Trie树仅支持保存字符串。</p>
<p>ART则是在Trie树的基础上，解决了它缺点的同时，保留了它的优点。下面我们来介绍ART索引。</p>
<p>对于一个索引而言，我们希望它有以下两个特点</p>
<ol>
<li>查询速度快</li>
<li>空间占用小</li>
</ol>
<p>但是如果我们使用Trie树做索引(ART是Trie的一个变种)，我们就要面临取舍，如果内部节点可以拥有的最大子结点越多(空间占据越多)，那么它的高度也越低(速度越快)。如果内部节点拥有的最大子结点越少(空间占据越少)，那么他的高度也越高(速度越慢)。</p>
<div style="text-align: center">
<img src="/pic/duckdb/trade-off.png"/>
</div>
<p>ART树选择每个内部节点的大小为8bit(子结点的数量为256),刚好是一个<code>byte</code>。这样的好处是免去了内存对齐的问题，同时在空间与速度上取得了一个较好的平衡。我们称内部节点所占据的位宽为<code>span</code>.</p>
<p>尽管如此，面对稀疏的数据时，每个节点有256个子结点仍旧会浪费空间，为了解决这个问题。ART将内部节点进一步细分为以下四类, 我们分别来对其进行介绍。</p>
<ol>
<li><strong>Node4</strong></li>
<li><strong>Node16</strong></li>
<li><strong>Node48</strong></li>
<li><strong>Node256</strong></li>
</ol>
<h3 id="node4">Node4</h3>
<div style="text-align: center">
<img src="/pic/duckdb/node4.png"/>
</div>
从图中可以看出，Node4分为两个部分，一个是key数组，一个是child数组。`key数组`存放key的部分内容(也就是key的一个byte)，`child数组`则是保存对应的子结点的指针。注意，我们为了可以范围查询，key数组要求顺序存储。
<h3 id="node16">Node16</h3>
<div style="text-align: center">
<img src="/pic/duckdb/node16.png"/>
</div>
Node16和Node4几乎一样，区别只是从4个`slot`变为16个`slot`
<h3 id="node48">Node48</h3>
<div style="text-align: center">
<img src="/pic/duckdb/node48.png"/>
</div>
Node48和之前介绍的Node一样也是分为`key数组`和`child数组`,区别在于Node48的`key数组`长度为256,这样子我们就无须通过遍历找到对应的数组，而是可以直接通过key的二进制值作为下标直接定位到对应的`key slot`。`key slot`中存放的是指针，指向对应的子结点在child数组中的位置。因此child数组的长度仅需要48就可以了。
<p>实际查询仅需要<code>child_array[key_array[key]]</code>即可。</p>
<h3 id="node256">Node256</h3>
<div style="text-align: center">
<img src="/pic/duckdb/node256.png"/>
</div>
Node256就是Trie树原始的内部节点表示形式，仅需要一个数组，数组的下标即为key，数组中存放的就是子结点的指针。
<p>各种不同类型的Node可以相互转换，如果子结点数量超过限制容量就向上转换，如果节点数量相较于限制容量太小就向下转换。</p>
<h3 id="leaf">Leaf</h3>
<p>ART中的叶节点存放的就是Key对应的Value值
ART的叶节点可以采用三种形式</p>
<ol>
<li>单独有一个叶节点类型专门保存Value</li>
<li>和中间节点保持一致的类型，唯一区别则是child数组不保存指针而是值</li>
<li>如果值足够小可以通过位操作和指针一起保存，那么我们可以将值直接存放在内部节点中。</li>
</ol>
<p>DuckDB采用的是第一种方式。</p>
<h3 id="优化">优化</h3>
<p>在解决了ART的空间问题，我们希望可i进一步优化查询速度，即减少树的高度。论文中有两种方式，但实际上我们可以通过一种简单的做法同时获得这两种优化，每个节点加上Prefix标识。</p>
<ol>
<li>lazy expansion</li>
</ol>
<div style="text-align: center">
<img src="/pic/duckdb/lazy-expansion.png"/>
</div>
其实这个优化相当简单，我们只需`Leaf`可以保存多个byte即可，这样子对于多个只有一个子结点的路径来说，我们可以将其都保存在`Leaf`中，从而减少树的高度。
<ol start="2">
<li>path compression</li>
</ol>
<div style="text-align: center">
<img src="/pic/duckdb/path-compress.png"/>
</div>
这个优化和lazy expansion类似，我们只需让`内部节点`可以保存多个byte即可。即如果内部节点有相同的前缀，我们可以将其保存在Prefix中，`key数组`仅仅只对**key不同**的部分作区分。这样子也可以有效的减少树的高度。
<p>如果这里没看懂也没关系，后续我们会分析DuckDB的代码，那样会更加清晰。</p>
<h3 id="数据转换">数据转换</h3>
<p>对于ART来说，我们前面介绍的都是对于字符串类型，如果作为一个被广泛使用的索引，那我们也需要支持不同类型的数据。而ART索引实际上是把<code>Key</code>作为数据流进行处理的，也就是说如果想要通过ART进行范围搜索，我们需要让<code>Key</code>保持一个性质，即二进制的大小与该类型的语义大小相同。即
$$
\text{memcmp}(binary(x), binary(y)) &lt; 0 \iff \text{x} &lt; \text{y}
$$</p>
<p>$$
\text{memcmp}(binary(x), binary(y)) = 0 \iff \text{x} = \text{y}
$$</p>
<p>$$
\text{memcmp}(binary(x), binary(y)) &gt; 0 \iff \text{x} &gt; \text{y}
$$</p>
<p>因此我们需要对某些数字进行转换</p>
<ol>
<li>
<p><strong>unsigned integers</strong></p>
<p>无需转化，已经满足需求。</p>
</li>
<li>
<p><strong>signed integers</strong></p>
<p>将符号位flip即可</p>
</li>
<li>
<p><strong>Floating Point Numbers</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">static</span> <span style="color:#080;font-weight:bold">inline</span> <span style="color:#339;font-weight:bold">uint32_t</span> <span style="color:#06b;font-weight:bold">EncodeFloat</span>(<span style="color:#339;font-weight:bold">float</span> x) {
</span></span><span style="display:flex;"><span>	<span style="color:#339;font-weight:bold">uint64_t</span> buff;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">//! zero
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">if</span> (x <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>		buff <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>		buff <span style="color:#333">|=</span> (<span style="color:#00d;font-weight:bold">1u</span> <span style="color:#333">&lt;&lt;</span> <span style="color:#00d;font-weight:bold">31</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> buff;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#888">// nan
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">if</span> (Value<span style="color:#333">::</span>IsNan(x)) {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> UINT_MAX;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#888">//! infinity
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">if</span> (x <span style="color:#333">&gt;</span> FLT_MAX) {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> UINT_MAX <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#888">//! -infinity
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">if</span> (x <span style="color:#333">&lt;</span> <span style="color:#333">-</span>FLT_MAX) {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	buff <span style="color:#333">=</span> Load<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">uint32_t</span><span style="color:#333">&gt;</span>(const_data_ptr_cast(<span style="color:#333">&amp;</span>x));
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> ((buff <span style="color:#333">&amp;</span> (<span style="color:#00d;font-weight:bold">1u</span> <span style="color:#333">&lt;&lt;</span> <span style="color:#00d;font-weight:bold">31</span>)) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) { <span style="color:#888">//! +0 and positive numbers
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		buff <span style="color:#333">|=</span> (<span style="color:#00d;font-weight:bold">1u</span> <span style="color:#333">&lt;&lt;</span> <span style="color:#00d;font-weight:bold">31</span>);
</span></span><span style="display:flex;"><span>	} <span style="color:#080;font-weight:bold">else</span> {          <span style="color:#888">//! negative numbers
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		buff <span style="color:#333">=</span> <span style="color:#333">~</span>buff; <span style="color:#888">//! complement 1
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">return</span> buff;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>Character Strings</strong></p>
<p>UCA算法已经做出了定义</p>
</li>
<li>
<p><strong>Null</strong></p>
<p>我们可以将该值设置为比最大位数仍多1位。</p>
</li>
<li>
<p><strong>Compound Keys</strong></p>
<p>按照其包含的基本类型进行拼接即可</p>
</li>
</ol>
<h2 id="源码解析">源码解析</h2>
<p>这一章节我们通过阅读DuckDB的源码，来看一下ART索引的实现。
ART索引的相关实现都在<code>art.cpp</code>和<code>art.hpp</code>，我们主要关注<code>Insert</code>和<code>Find</code>, 其他的函数留给读者自行了解。</p>
<h3 id="insert">Insert</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">bool</span> ART<span style="color:#333">::</span>Insert(Node <span style="color:#333">&amp;</span>node, <span style="color:#080;font-weight:bold">const</span> ARTKey <span style="color:#333">&amp;</span>key, idx_t depth, <span style="color:#080;font-weight:bold">const</span> row_t <span style="color:#333">&amp;</span>row_id) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>node.IsSet()) {
</span></span><span style="display:flex;"><span>		<span style="color:#888">// node is currently empty, create a leaf here with the key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key, depth, row_id);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (node.DecodeARTNodeType() <span style="color:#333">==</span> NType<span style="color:#333">::</span>LEAF) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add a row ID to a leaf, if they have the same key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>leaf <span style="color:#333">=</span> Leaf<span style="color:#333">::</span>Get(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> mismatch_position <span style="color:#333">=</span> leaf.prefix.KeyMismatchPosition(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// identical equal
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">if</span> (mismatch_position <span style="color:#333">==</span> leaf.prefix.count <span style="color:#333">&amp;&amp;</span> depth <span style="color:#333">+</span> leaf.prefix.count <span style="color:#333">==</span> key.len) {
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">InsertToLeaf</span>(node, row_id);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// example:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// prefix : hello
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// key[depth] : heel;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// mismatch_position = 2
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// replace leaf with Node4 and store both leaves in it
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> old_node <span style="color:#333">=</span> node;
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>new_n4 <span style="color:#333">=</span> Node4<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// new prefix
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// new_n4&#39;s prefix is he
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		new_n4.prefix.Initialize(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// old_node&#39;s prefix change to llo
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> key_byte <span style="color:#333">=</span> old_node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>).Reduce(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add child
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key_byte, old_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		Node leaf_node;
</span></span><span style="display:flex;"><span>		Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> mismatch_position <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add child
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth <span style="color:#333">+</span> mismatch_position], leaf_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// handle prefix of inner node
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>old_node_prefix <span style="color:#333">=</span> node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (old_node_prefix.count) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> mismatch_position <span style="color:#333">=</span> old_node_prefix.KeyMismatchPosition(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">if</span> (mismatch_position <span style="color:#333">!=</span> old_node_prefix.count) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#888">// prefix differs, create new node
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>			<span style="color:#080;font-weight:bold">auto</span> old_node <span style="color:#333">=</span> node;
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>new_n4 <span style="color:#333">=</span> Node4<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>			new_n4.prefix.Initialize(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">auto</span> key_byte <span style="color:#333">=</span> old_node_prefix.Reduce(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, mismatch_position);
</span></span><span style="display:flex;"><span>			Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key_byte, old_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			Node leaf_node;
</span></span><span style="display:flex;"><span>			Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> mismatch_position <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>			Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth <span style="color:#333">+</span> mismatch_position], leaf_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		depth <span style="color:#333">+=</span> node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>).count;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// recurse
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	D_ASSERT(depth <span style="color:#333">&lt;</span> key.len);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">auto</span> child <span style="color:#333">=</span> node.GetChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key[depth]);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (child) {
</span></span><span style="display:flex;"><span>		<span style="color:#339;font-weight:bold">bool</span> success <span style="color:#333">=</span> Insert(<span style="color:#333">*</span>child, key, depth <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>		node.ReplaceChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key[depth], <span style="color:#333">*</span>child);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> success;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// insert at position
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	Node leaf_node;
</span></span><span style="display:flex;"><span>	Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>	Node<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth], leaf_node);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码还是比较多的，我们先介绍一下参数的意义</p>
<ol>
<li>
<p><strong>node</strong> 即为当前要进行插入的节点.</p>
</li>
<li>
<p><strong>key</strong> 即为要插入的key</p>
</li>
<li>
<p><strong>depth</strong></p>
<p>即当前已经处理到key的第几个byte,举个例子，key为<code>hello</code>, depth为3，那么说明<code>he</code>已经保存在了node的祖先节点中，我们当前要处理的是<code>l</code>。</p>
</li>
<li>
<p><strong>row_id</strong> 即为key对应的value值.</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">bool</span> ART<span style="color:#333">::</span>Insert(Node <span style="color:#333">&amp;</span>node, <span style="color:#080;font-weight:bold">const</span> ARTKey <span style="color:#333">&amp;</span>key, idx_t depth, <span style="color:#080;font-weight:bold">const</span> row_t <span style="color:#333">&amp;</span>row_id) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>node.IsSet()) {
</span></span><span style="display:flex;"><span>		<span style="color:#888">// node is currently empty, create a leaf here with the key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key, depth, row_id);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果当前节点为空，那么直接设置该节点为叶节点，并且将<code>row_id</code>进行保存，注意这里我们会使用<code>lazy-expansion</code>, 即将key剩余未处理的字符全部保存在叶节点中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">bool</span> ART<span style="color:#333">::</span>Insert(Node <span style="color:#333">&amp;</span>node, <span style="color:#080;font-weight:bold">const</span> ARTKey <span style="color:#333">&amp;</span>key, idx_t depth, <span style="color:#080;font-weight:bold">const</span> row_t <span style="color:#333">&amp;</span>row_id) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// .... skip
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">if</span> (node.DecodeARTNodeType() <span style="color:#333">==</span> NType<span style="color:#333">::</span>LEAF) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add a row ID to a leaf, if they have the same key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>leaf <span style="color:#333">=</span> Leaf<span style="color:#333">::</span>Get(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> mismatch_position <span style="color:#333">=</span> leaf.prefix.KeyMismatchPosition(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// identical equal
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">if</span> (mismatch_position <span style="color:#333">==</span> leaf.prefix.count <span style="color:#333">&amp;&amp;</span> depth <span style="color:#333">+</span> leaf.prefix.count <span style="color:#333">==</span> key.len) {
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">InsertToLeaf</span>(node, row_id);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// example:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// prefix : hello
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// key[depth] : heel;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// mismatch_position = 2
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// replace leaf with Node4 and store both leaves in it
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> old_node <span style="color:#333">=</span> node;
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>new_n4 <span style="color:#333">=</span> Node4<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// new prefix
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#888">// new_n4&#39;s prefix is he
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		new_n4.prefix.Initialize(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// old_node&#39;s prefix change to llo
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> key_byte <span style="color:#333">=</span> old_node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>).Reduce(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add child
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key_byte, old_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		Node leaf_node;
</span></span><span style="display:flex;"><span>		Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> mismatch_position <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>		<span style="color:#888">// add child
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth <span style="color:#333">+</span> mismatch_position], leaf_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#888">//skip....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><p>如果当前遇到的是叶节点，同时key完全相同，那么我们可以直接将<code>row_id</code>插入叶节点中。不然的话，我们需要将叶节点变为内部节点，同时将不同的部分作为该内部节点的叶节点。如下图所示。</p>
<div style="text-align: center">
<img src="/pic/duckdb/leaf-insert.png"/>
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">bool</span> ART<span style="color:#333">::</span>Insert(Node <span style="color:#333">&amp;</span>node, <span style="color:#080;font-weight:bold">const</span> ARTKey <span style="color:#333">&amp;</span>key, idx_t depth, <span style="color:#080;font-weight:bold">const</span> row_t <span style="color:#333">&amp;</span>row_id) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// skip ....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#888">// handle prefix of inner node
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>old_node_prefix <span style="color:#333">=</span> node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (old_node_prefix.count) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> mismatch_position <span style="color:#333">=</span> old_node_prefix.KeyMismatchPosition(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">if</span> (mismatch_position <span style="color:#333">!=</span> old_node_prefix.count) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#888">// prefix differs, create new node
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>			<span style="color:#080;font-weight:bold">auto</span> old_node <span style="color:#333">=</span> node;
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>new_n4 <span style="color:#333">=</span> Node4<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>			new_n4.prefix.Initialize(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key, depth, mismatch_position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">auto</span> key_byte <span style="color:#333">=</span> old_node_prefix.Reduce(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, mismatch_position);
</span></span><span style="display:flex;"><span>			Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key_byte, old_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			Node leaf_node;
</span></span><span style="display:flex;"><span>			Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> mismatch_position <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>			Node4<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth <span style="color:#333">+</span> mismatch_position], leaf_node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		depth <span style="color:#333">+=</span> node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>).count;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// recurse
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	D_ASSERT(depth <span style="color:#333">&lt;</span> key.len);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">auto</span> child <span style="color:#333">=</span> node.GetChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key[depth]);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">if</span> (child) {
</span></span><span style="display:flex;"><span>		<span style="color:#339;font-weight:bold">bool</span> success <span style="color:#333">=</span> Insert(<span style="color:#333">*</span>child, key, depth <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>		node.ReplaceChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key[depth], <span style="color:#333">*</span>child);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">return</span> success;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#888">// insert at position
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>	Node leaf_node;
</span></span><span style="display:flex;"><span>	Leaf<span style="color:#333">::</span>New(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, leaf_node, key, depth <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, row_id);
</span></span><span style="display:flex;"><span>	Node<span style="color:#333">::</span>InsertChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node, key[depth], leaf_node);
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果是内部节点，那我们需要讨论</p>
<ol>
<li>如果前缀完全相同，即“hello&quot;和”hellopxxx“。那么我们仅需要找出子结点进行插入即可。如下图所示。</li>
</ol>
<div style="text-align: center">
<img src="/pic/duckdb/node-insert1.png"/>
</div>
<ol start="2">
<li>如果前缀有不同指出，那么我们需要创建一个新的节点。并将两个节点作为子结点进行插入。如下图所示。</li>
</ol>
<div style="text-align: center">
<img src="/pic/duckdb/node-insert2.png"/>
</div>
<p>可以看到，我们只需要在内部节点，和叶节点中支持存储多个字符后，便天然支持上述的有化方案。</p>
<h3 id="find">Find</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>Node ART<span style="color:#333">::</span>Lookup(Node node, <span style="color:#080;font-weight:bold">const</span> ARTKey <span style="color:#333">&amp;</span>key, idx_t depth) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">while</span> (node.IsSet()) {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">if</span> (node.DecodeARTNodeType() <span style="color:#333">==</span> NType<span style="color:#333">::</span>LEAF) {
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>leaf <span style="color:#333">=</span> Leaf<span style="color:#333">::</span>Get(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#888">// check if leaf contains key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>			<span style="color:#080;font-weight:bold">for</span> (idx_t i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> leaf.prefix.count; i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#080;font-weight:bold">if</span> (leaf.prefix.GetByte(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, i) <span style="color:#333">!=</span> key[i <span style="color:#333">+</span> depth]) {
</span></span><span style="display:flex;"><span>					<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">Node</span>();
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">auto</span> <span style="color:#333">&amp;</span>node_prefix <span style="color:#333">=</span> node.GetPrefix(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">if</span> (node_prefix.count) {
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">for</span> (idx_t pos <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; pos <span style="color:#333">&lt;</span> node_prefix.count; pos<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#080;font-weight:bold">if</span> (key[depth <span style="color:#333">+</span> pos] <span style="color:#333">!=</span> node_prefix.GetByte(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, pos)) {
</span></span><span style="display:flex;"><span>					<span style="color:#888">// prefix mismatch, subtree of node does not contain key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>					<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">Node</span>();
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			depth <span style="color:#333">+=</span> node_prefix.count;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// prefix matches key, but no child at byte, does not contain key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">auto</span> child <span style="color:#333">=</span> node.GetChild(<span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>, key[depth]);
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>child) {
</span></span><span style="display:flex;"><span>			<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">Node</span>();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#888">// recurse into child
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>		node <span style="color:#333">=</span> <span style="color:#333">*</span>child;
</span></span><span style="display:flex;"><span>		D_ASSERT(node.IsSet());
</span></span><span style="display:flex;"><span>		depth<span style="color:#333">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">Node</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>查找的代码相对来说比较简单</p>
<ol>
<li>查找到了 <code>Leaf</code> 节点,检查Prefix是否匹配。如果不匹配说明Key不存在，若匹配直接返回该叶节点即可。</li>
<li>查找到了 <code>内部节点</code>,检查Prefix是否匹配。如果不匹配说明Key不存在，若匹配继续搜索对应的子节点。</li>
</ol>
<h2 id="last">Last</h2>
<p>本文介绍了DuckDB的ART索引，可以看到尽管ART索引的树会比B+树更高，因此如果是面向磁盘的情况下，B+树会比ART索引优势更大，但是如果是内存索引的情况下，ART索引更加紧凑，同时他的渐进时间复杂度仅与key的长度有关，可能也更加cache friendly？它的节点相较于B+树更加的小，可以更多的保存在cache中。从论文中的实验来看，它的性能会比B+树更好。相较于<code>Hash table</code>,它支持范围查询。基于此DuckDB将ART索引作为其的主要索引。</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/database/">database</a>
<a href="/categories/duckdb/">duckdb</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
