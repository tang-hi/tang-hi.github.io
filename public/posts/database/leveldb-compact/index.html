<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>LevelDB(3) -- 压实与版本 | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的压实与版本">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="LevelDB(3) -- 压实与版本" />
<meta property="og:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的压实与版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/database/leveldb-compact/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-21T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="LevelDB(3) -- 压实与版本"/>
<meta name="twitter:description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的压实与版本"/>

<meta itemprop="name" content="LevelDB(3) -- 压实与版本">
<meta itemprop="description" content="LevelDB 是一个高效的KV数据库，本文将介绍LevelDB的压实与版本"><meta itemprop="datePublished" content="2023-06-21T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-06-21T00:00:00+00:00" />
<meta itemprop="wordCount" content="2316">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">21</span>
<span class="rest">Jun 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">LevelDB(3) -- 压实与版本</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;11&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;2316&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>本文将介绍LevelDB的压实操作，以及相应的版本管理。</p>
<h2 id="compact">Compact</h2>
<p>通过前面的文章，我们知道<code>LevelDB</code>会先将添加的<code>KV</code>写入到内存中的<code>MemTable</code>中，等到<code>MemTable</code>到达一定阈值后，再将<code>MemTable</code>dump到磁盘中，而且<code>LevelDB</code>为了写的性能，并不会做<code>update-in-place</code>,而是标记删除。这就会导致，随着数据的增多，无用的数据也增多(被标记删除的旧记录)，文件数也会越来越多。因此我们需要将多个小文件合并为一个大文件，从而删除无用的数据，并且减少文件数从而提升查询性能。</p>
<p>合并可以减少空间的占用也许比较好理解，但是为什么减少文件数可以提升性能呢？首先，如果文件数多，那么做一个查询时，需要查询的文件数也相应会变多。其次通过压实合并文件，同一<code>level</code>中的文件可以保证<code>key</code>之间没有重叠，从而每一层只需要查找一个文件即可，不同<code>level</code>之间的文件中的<code>key</code>也尽可能没有重叠。</p>
<p>下面我们来看一下<code>LevelDB</code>的Compact实现</p>
<h3 id="compact的时机">Compact的时机</h3>
<p><code>LevelDB</code>在三种情况下会尝试触发Compact</p>
<ol>
<li>DB刚被打开时，此时会尝试触发一次Compact</li>
<li>有数据写入时，此时也会尝试触发一次Compact</li>
<li>查询数据时，也会尝试触发一次Compact</li>
</ol>
<p>第一种情况没什么好说的，就是打开的时候看看能不能让整个<code>DB</code>更整洁。</p>
<p>第二种情况则是如果数据写入前，发现<code>MemTable</code>已经到达阈值了，那么此时需要将当前的<code>MemTable</code>dump到磁盘中（这也是一种压实）dump的具体细节在 <a href="../leveldb-write/">LevelDB(1) – 写::ldb文件的格式与生成</a>。</p>
<p>第三种情况则是查询数据时，如果我们一次查询，查询了多个文件，这就说明level与level之间有<code>key</code>重叠（同level中key不重叠,除了level-0，因此如果查询了多个文件说明一定涉及多个level), 对于这种情况我们会记录这个文件被查询的次数,当到达阈值后，我们就要尝试进行<code>Compact</code>，这样子后续再查时，我们可能只需要查找一个文件就可以了。</p>
<p>一个文件可以被查询的阈值是如何设置的，我们直接看代码与注释，相信就可以很好的理解了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span> 	  <span style="color:#888">// We arrange to automatically compact this file after
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// a certain number of seeks.  Let&#39;s assume:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//   (1) One seek costs 10ms
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//   (2) Writing or reading 1MB costs 10ms (100MB/s)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//   (3) A compaction of 1MB does 25MB of IO:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//         1MB read from this level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//         10-12MB read from next level (boundaries may be misaligned)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//         10-12MB written to next level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// This implies that 25 seeks cost the same as the compaction
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// of 1MB of data.  I.e., one seek costs approximately the
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// same as the compaction of 40KB of data.  We are a little
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// conservative and allow approximately one seek for every 16KB
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// of data before triggering a compaction.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">static_cast</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span><span style="color:#333">&gt;</span>((f<span style="color:#333">-&gt;</span>file_size <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">16384U</span>));
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">100</span>) f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      levels_[level].deleted_files.erase(f<span style="color:#333">-&gt;</span>number);
</span></span><span style="display:flex;"><span>      levels_[level].added_files<span style="color:#333">-&gt;</span>insert(f);
</span></span></code></pre></div><h3 id="compact的实现">Compact的实现</h3>
<p>我们先看代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> DBImpl<span style="color:#333">::</span>BackgroundCall() {
</span></span><span style="display:flex;"><span>  MutexLock <span style="color:#06b;font-weight:bold">l</span>(<span style="color:#333">&amp;</span>mutex_);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 该标识已经在 DBImpl::MaybeScheduleCompaction 进行设置
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  assert(background_compaction_scheduled_);
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (shutting_down_.Acquire_Load()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// No more background work when shutting down.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  } <span style="color:#080;font-weight:bold">else</span> <span style="color:#06b;font-weight:bold">if</span> (<span style="color:#333">!</span>bg_error_.ok()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// No more background work after a background error.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 执行具体的压实任务
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    BackgroundCompaction();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  background_compaction_scheduled_ <span style="color:#333">=</span> <span style="color:#007020">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 前一次压实可能在某个 level 产生了过多文件, 所以再调度
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 一次压实, 如果判断真得需要的话.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  MaybeScheduleCompaction();
</span></span><span style="display:flex;"><span>  background_work_finished_signal_.SignalAll();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这里我们可以看到，我们再<code>Compact</code>后，仍然会尝试再次<code>Compact</code>这是因为再上一次的<code>Compact</code>后，可能我们产生了过多的文件，从而需要再次<code>Compact</code>.</p>
<p>下面的代码是<code>Compact</code>的具体实现.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#888">// 该方法仅在 DBImpl::BackgroundCall 调用
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#339;font-weight:bold">void</span> DBImpl<span style="color:#333">::</span>BackgroundCompaction() {
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 压实过程需要全程持有锁, 这也暗示压实不能耗费太多时间.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  mutex_.AssertHeld();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 先压实已满的 memtable
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (imm_ <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>    CompactMemTable();
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 如果手动触发了一个压实
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (is_manual) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 否则根据统计信息确定待压实 level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    c <span style="color:#333">=</span> versions_<span style="color:#333">-&gt;</span>PickCompaction();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Status status;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (c <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 无需压实
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  } <span style="color:#080;font-weight:bold">else</span> <span style="color:#06b;font-weight:bold">if</span> (<span style="color:#333">!</span>is_manual <span style="color:#333">&amp;&amp;</span> c<span style="color:#333">-&gt;</span>IsTrivialMove()) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 不做压实, 直接把文件从 level 移动到 level+1
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    assert(c<span style="color:#333">-&gt;</span>num_input_files(<span style="color:#00d;font-weight:bold">0</span>) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    FileMetaData<span style="color:#333">*</span> f <span style="color:#333">=</span> c<span style="color:#333">-&gt;</span>input(<span style="color:#00d;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 将该文件从 level 层删除
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    c<span style="color:#333">-&gt;</span>edit()<span style="color:#333">-&gt;</span>DeleteFile(c<span style="color:#333">-&gt;</span>level(), f<span style="color:#333">-&gt;</span>number);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 将该文件增加到 level+1
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    c<span style="color:#333">-&gt;</span>edit()<span style="color:#333">-&gt;</span>AddFile(c<span style="color:#333">-&gt;</span>level() <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>, f<span style="color:#333">-&gt;</span>number, f<span style="color:#333">-&gt;</span>file_size,
</span></span><span style="display:flex;"><span>                       f<span style="color:#333">-&gt;</span>smallest, f<span style="color:#333">-&gt;</span>largest);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 应用本次移动操作
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    status <span style="color:#333">=</span> versions_<span style="color:#333">-&gt;</span>LogAndApply(c<span style="color:#333">-&gt;</span>edit(), <span style="color:#333">&amp;</span>mutex_);
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>      RecordBackgroundError(status);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    VersionSet<span style="color:#333">::</span>LevelSummaryStorage tmp;
</span></span><span style="display:flex;"><span>    Log(options_.info_log, <span style="background-color:#fff0f0">&#34;Moved #%lld to level-%d %lld bytes %s: %s</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\n</span><span style="background-color:#fff0f0">&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">static_cast</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">long</span> <span style="color:#339;font-weight:bold">long</span><span style="color:#333">&gt;</span>(f<span style="color:#333">-&gt;</span>number),
</span></span><span style="display:flex;"><span>        c<span style="color:#333">-&gt;</span>level() <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">static_cast</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">long</span> <span style="color:#339;font-weight:bold">long</span><span style="color:#333">&gt;</span>(f<span style="color:#333">-&gt;</span>file_size),
</span></span><span style="display:flex;"><span>        status.ToString().c_str(),
</span></span><span style="display:flex;"><span>        versions_<span style="color:#333">-&gt;</span>LevelSummary(<span style="color:#333">&amp;</span>tmp));
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    CompactionState<span style="color:#333">*</span> compact <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> CompactionState(c);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 做压实
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    status <span style="color:#333">=</span> DoCompactionWork(compact);
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>      RecordBackgroundError(status);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 清理压实现场
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    CleanupCompaction(compact);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 释放压实用到的输入文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    c<span style="color:#333">-&gt;</span>ReleaseInputs();
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 删除过期文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    DeleteObsoleteFiles();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">delete</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">//....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><p>从代码中可以看到，整个<code>Compact</code>的实现分为两部分，如果有需要被dump到磁盘的<code>MemTable</code>,那么就直接进行压实。具体流程我在<a href="../leveldb-write/">LevelDB(1) – 写::ldb文件的格式与生成</a>有详细的描述，这里不赘述。在本篇文章中，我们主要关注第二部分，即<code>自动Compact</code>。</p>
<p>首先我们会尝试挑选出需要被<code>Compact</code>的level。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>	Compaction<span style="color:#333">*</span> c;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> level;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">bool</span> size_compaction <span style="color:#333">=</span> (current_<span style="color:#333">-&gt;</span>compaction_score_ <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">bool</span> seek_compaction <span style="color:#333">=</span> (current_<span style="color:#333">-&gt;</span>file_to_compact_ <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 我们倾向于因为某层数据太多而触发的压实,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 而非因为查询次数超过上限(即 FileMetaData-&gt;allowed_seeks)触发的压实.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 实现办法就是先检查大小后检查查询次数.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 先看有无 level 存储比值已经超过上限
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (size_compaction) {
</span></span><span style="display:flex;"><span>    level <span style="color:#333">=</span> current_<span style="color:#333">-&gt;</span>compaction_level_;
</span></span><span style="display:flex;"><span>    assert(level <span style="color:#333">&gt;=</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    assert(level<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">&lt;</span> config<span style="color:#333">::</span>kNumLevels);
</span></span><span style="display:flex;"><span>    c <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Compaction(options_, level);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 找到待压实 level 第一个可能包含 compact_pointer_[level] 的文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (size_t i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> current_<span style="color:#333">-&gt;</span>files_[level].size(); i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      FileMetaData<span style="color:#333">*</span> f <span style="color:#333">=</span> current_<span style="color:#333">-&gt;</span>files_[level][i];
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (compact_pointer_[level].empty() <span style="color:#333">||</span>
</span></span><span style="display:flex;"><span>          icmp_.Compare(f<span style="color:#333">-&gt;</span>largest.Encode(), compact_pointer_[level]) <span style="color:#333">&gt;</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 把这个文件追加到 level 对应的待压实文件集合中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>].push_back(f);
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果 level 对应的待压实文件集合为空(说明 compact_pointer_[level]
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 位于 level 最后一个文件之后), 则回绕到开头, 将其第一个
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 文件加入到待压实集合.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>].empty()) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Wrap-around to the beginning of the key space
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>].push_back(current_<span style="color:#333">-&gt;</span>files_[level][<span style="color:#00d;font-weight:bold">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> <span style="color:#06b;font-weight:bold">if</span> (seek_compaction) { <span style="color:#888">// 再看是否有文件因为查询次数过多
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// (Version::Get() 时候疑似包含但实际不包含目标 key 的最底层
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// level 的第一个文件会被记录到统计信息中, 然后会被 Version::UpdateStats() 处理)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 而可以触发压实
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    level <span style="color:#333">=</span> current_<span style="color:#333">-&gt;</span>file_to_compact_level_;
</span></span><span style="display:flex;"><span>    c <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Compaction(options_, level);
</span></span><span style="display:flex;"><span>    c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>].push_back(current_<span style="color:#333">-&gt;</span>file_to_compact_);
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  c<span style="color:#333">-&gt;</span>input_version_ <span style="color:#333">=</span> current_;
</span></span><span style="display:flex;"><span>  c<span style="color:#333">-&gt;</span>input_version_<span style="color:#333">-&gt;</span>Ref();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// level-0 文件可能彼此重叠, 所以要把全部重叠文件都加入到待压实文件集合中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (level <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>    InternalKey smallest, largest;
</span></span><span style="display:flex;"><span>    GetRange(c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>], <span style="color:#333">&amp;</span>smallest, <span style="color:#333">&amp;</span>largest);
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Note that the next call will discard the file we placed in
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// c-&gt;inputs_[0] earlier and replace it with an overlapping set
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// which will include the picked file.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 注意下面这个方法会清除 inputs[0] 内容, 不过不用担心, 由于已经提前提取到了
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// inputs[0] 键范围所以下面这个方法会把那个被清除的文件重新捞回来.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    current_<span style="color:#333">-&gt;</span>GetOverlappingInputs(<span style="color:#00d;font-weight:bold">0</span>, <span style="color:#333">&amp;</span>smallest, <span style="color:#333">&amp;</span>largest, <span style="color:#333">&amp;</span>c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>]);
</span></span><span style="display:flex;"><span>    assert(<span style="color:#333">!</span>c<span style="color:#333">-&gt;</span>inputs_[<span style="color:#00d;font-weight:bold">0</span>].empty());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 将 level+1 中与 level 对应待压实集合重叠的文件拿出来做压实
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  SetupOtherInputs(c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> c;
</span></span></code></pre></div><p>根据<code>Compact</code>的触发原因不同，我们采用不同的策略</p>
<ol>
<li>由于某一层的数据超过阈值导致的<code>Compact</code>,对于这种情况我们采用<code>round-robin</code>的方式来进行<code>Compact</code>，即如果上一次<code>Compact</code>的最大的key为“A1”，那么我们这一次就挑选出比&quot;A1&quot;大的文件来做<code>Compact</code>.</li>
<li>如果是由于查询次数过大导致的<code>Compact</code>,那么我们就直接选择该文件来做<code>Compact</code></li>
</ol>
<p>注意，我们会对<code>Level-0</code>做特殊的处理，因为<code>Level-0</code>中文件的Key会重叠，因此我们会将所有Key重叠的文件都作为准备<code>Compact</code>的候选项。</p>
<p>在获得需要<code>Compact</code>的文件后，我们需要在上一层寻找与当前层重叠的文件作为一个整体一起compact。如下图所示。</p>
<div style="text-align: center">
<img src="/pic/levelDB/pick-level.png"/>
</div>
<p>在得到上一层准备被<code>Compact</code>的文件后，我们会获得key的范围，如上图所示，一开始<code>Level-x</code>的范围为（50-700），在得到<code>Level-x+1</code>准备被Compact的文件后,范围来到了(50-720)。在某些情况下，我们在<strong>不改变<code>Level-x+1</code>准备被Compact的文件数</strong>的前提下，从<code>Level-x</code>中选择更多的文件来进行<code>Compact</code>，从而使得<code>Compact</code>的效率更高。之所以不改变<code>Level-x+1</code>准备被Compact的文件数，是为了防止无限制的循环下去，从而导致<code>Level-x</code>和<code>Level-x+1</code>的所有文件全部都需要进行<code>Compact</code>。</p>
<p>在决定了需要<code>Compact</code>的文件后，我们有两种方式进行<code>Compact</code></p>
<h4 id="trivialmove">TrivialMove</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">return</span> (num_input_files(<span style="color:#00d;font-weight:bold">0</span>) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">&amp;&amp;</span> num_input_files(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span> <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          TotalFileSize(grandparents_) <span style="color:#333">&lt;=</span>
</span></span><span style="display:flex;"><span>              MaxGrandParentOverlapBytes(vset<span style="color:#333">-&gt;</span>options_));
</span></span></code></pre></div><p>如果 <code>level</code> 层只有 1 个待压实文件 ， <code>level+1</code> 层没有与 <code>level</code> 待压实文件发生重叠的文件 且 <code>level+2 层与 level</code> 待压实文件重叠的字节数不大于上限,则可以用移动替代压实.这里之所以要判断**<code>level+2 层与 level</code> 待压实文件重叠的字节数不大于上限** 是因为如果 <code>level</code> 与祖父(即 <code>level+2</code>) 有大量重叠数据, 合并后会创建一个父文件(即 <code>level+1</code>), 很显然这个文件和自己父亲 <code>level</code>(即上面说的 <code>level+2</code>)存在大量重叠数据, 这个情况会导致后续非常昂贵的合并.</p>
<h4 id="docompactionwork">DoCompactionWork</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#888">// 具体压实就做一件事情:
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 遍历待压实文件, 如果某个 key (位于 level-L 或者 level-(L+1))的类型属性取值为&#34;删除&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#888">// 则确认其在 level-(L+2) 或之上是否存在, 若不存在则丢弃之, 否则写入合并后的文件.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Status DBImpl<span style="color:#333">::</span>DoCompactionWork(CompactionState<span style="color:#333">*</span> compact) {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">uint64_t</span> start_micros <span style="color:#333">=</span> env_<span style="color:#333">-&gt;</span>NowMicros();
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 用于 imm_ 压实耗时统计
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">int64_t</span> imm_micros <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Log(options_.info_log,  <span style="background-color:#fff0f0">&#34;Compacting %d@%d + %d@%d files&#34;</span>,
</span></span><span style="display:flex;"><span>      compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>num_input_files(<span style="color:#00d;font-weight:bold">0</span>),
</span></span><span style="display:flex;"><span>      compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>level(),
</span></span><span style="display:flex;"><span>      compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>num_input_files(<span style="color:#00d;font-weight:bold">1</span>),
</span></span><span style="display:flex;"><span>      compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>level() <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert(versions_<span style="color:#333">-&gt;</span>NumLevelFiles(compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>level()) <span style="color:#333">&gt;</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>  assert(compact<span style="color:#333">-&gt;</span>builder <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>  assert(compact<span style="color:#333">-&gt;</span>outfile <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 如果快照列表为空, 则将最新的操作序列号作为最小的快照
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (snapshots_.empty()) {
</span></span><span style="display:flex;"><span>    compact<span style="color:#333">-&gt;</span>smallest_snapshot <span style="color:#333">=</span> versions_<span style="color:#333">-&gt;</span>LastSequence();
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 否则从快照列表获取最老的快照对应的序列号作为最小快照.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 虽然最老, 但是没有 release 就是要保障可见性的.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    compact<span style="color:#333">-&gt;</span>smallest_snapshot <span style="color:#333">=</span> snapshots_.oldest()<span style="color:#333">-&gt;</span>sequence_number();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 真正做压实工作的之前要释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  mutex_.Unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 针对待压实的全部文件创建一个大迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Iterator<span style="color:#333">*</span> input <span style="color:#333">=</span> versions_<span style="color:#333">-&gt;</span>MakeInputIterator(compact<span style="color:#333">-&gt;</span>compaction);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 迭代器指针拨到开头
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  input<span style="color:#333">-&gt;</span>SeekToFirst();
</span></span><span style="display:flex;"><span>  Status status;
</span></span><span style="display:flex;"><span>  ParsedInternalKey ikey;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 下面三个临时变量用来处理多个文件(如果压实涉及了 level-0)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 或多个 level 存在同名 user key 的问题, 典型地有如下两种:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 1. level-0 文件可能存在重叠, 同名 user key 后出现的更新,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 序列号也更大.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 2. 低 level  和高 level 之间可能重叠(这个可能其实是肯定,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 因为不重叠就不用压实了), 同名 user key 先出现的更新, 序列号也更大.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>string current_user_key;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_current_user_key <span style="color:#333">=</span> <span style="color:#007020">false</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 如果 user key 出现多次, 下面这个用于记录上次出现时对应的
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// internal key 的序列号.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  SequenceNumber last_sequence_for_key <span style="color:#333">=</span> kMaxSequenceNumber;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">for</span> (; input<span style="color:#333">-&gt;</span>Valid() <span style="color:#333">&amp;&amp;</span> <span style="color:#333">!</span>shutting_down_.Acquire_Load(); ) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 优先处理已经写满待压实的 memtable
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (has_imm_.NoBarrier_Load() <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">uint64_t</span> imm_start <span style="color:#333">=</span> env_<span style="color:#333">-&gt;</span>NowMicros();
</span></span><span style="display:flex;"><span>      mutex_.Lock();
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (imm_ <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// immutable memtable 落盘
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        CompactMemTable();
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 如有必要唤醒 MakeRoomForWrite()
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        background_work_finished_signal_.SignalAll();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      mutex_.Unlock();
</span></span><span style="display:flex;"><span>      imm_micros <span style="color:#333">+=</span> (env_<span style="color:#333">-&gt;</span>NowMicros() <span style="color:#333">-</span> imm_start);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 即将被处理的 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    Slice key <span style="color:#333">=</span> input<span style="color:#333">-&gt;</span>key();
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 当发现截止到 key, level 和 level+2 重叠数据量已经达到上限, 则
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 开始进行压实; key 也是压实的最右区间.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">//　一进来循环看到这个判断代码可能比较懵, 肯定看不太懂, 其实下面这个判断一般
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 要经过若干循环才能成立, 先看后面代码再回来看这个判断.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>ShouldStopBefore(key) <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        compact<span style="color:#333">-&gt;</span>builder <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 将压实生成的文件落盘
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      status <span style="color:#333">=</span> FinishCompactionOutputFile(compact, input);
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// Handle key/value, add to state, etc.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#339;font-weight:bold">bool</span> drop <span style="color:#333">=</span> <span style="color:#007020">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 反序列化 internal key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>ParseInternalKey(key, <span style="color:#333">&amp;</span>ikey)) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Do not hide error keys
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      current_user_key.clear();
</span></span><span style="display:flex;"><span>      has_current_user_key <span style="color:#333">=</span> <span style="color:#007020">false</span>;
</span></span><span style="display:flex;"><span>      last_sequence_for_key <span style="color:#333">=</span> kMaxSequenceNumber;
</span></span><span style="display:flex;"><span>    } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 如果这个 user key 之前迭代未出现过, 记下来
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>has_current_user_key <span style="color:#333">||</span>
</span></span><span style="display:flex;"><span>          user_comparator()<span style="color:#333">-&gt;</span>Compare(ikey.user_key,
</span></span><span style="display:flex;"><span>                                     Slice(current_user_key)) <span style="color:#333">!=</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
</span></span><span style="display:flex;"><span>        has_current_user_key <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 标记这个 user key 截止目前轮次迭代对应的序列号;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 因为是首次出现所以这里直接置为序列号最大可能取值.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 确保最新的数据一定不会被drop
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        last_sequence_for_key <span style="color:#333">=</span> kMaxSequenceNumber;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 序列号过小, 丢弃这个 key 本次迭代对应的数据; 后面还有这个 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 对应的更新的数据.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 上一个seq &lt;= smallest_snapshot, 那么这个必然 &lt; smallest_snapshot
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 因此可以直接丢弃。
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (last_sequence_for_key <span style="color:#333">&lt;=</span> compact<span style="color:#333">-&gt;</span>smallest_snapshot) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// Hidden by an newer entry for same user key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        drop <span style="color:#333">=</span> <span style="color:#007020">true</span>;    <span style="color:#888">// 规则 (A)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      } <span style="color:#080;font-weight:bold">else</span> <span style="color:#06b;font-weight:bold">if</span> (ikey.type <span style="color:#333">==</span> kTypeDeletion <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                 ikey.sequence <span style="color:#333">&lt;=</span> compact<span style="color:#333">-&gt;</span>smallest_snapshot <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                 compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>IsBaseLevelForKey(ikey.user_key)) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 对于这个 user key:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// (1) 更高的 levels(指的是祖父 level 及之上)没有对应数据了
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// (2) 更低的 levels 对应的数据的序列号会更大(这个是显然地)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// (3) 目前正在被压实的各个 levels(即 level 和 level+1) 中序列号
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 更小的数据在循环的未来几次迭代中会被丢弃(根据上面的规则(A)).
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 综上, 这个删除标记已经过期了并且可以被丢弃.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        drop <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>	  <span style="color:#888">// 如果没有snapshot，相同的user key只保存最新数据。
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      last_sequence_for_key <span style="color:#333">=</span> ikey.sequence;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#579">#if 0</span><span style="color:#888">
</span></span></span><span style="display:flex;"><span><span style="color:#888">    Log(options_.info_log,
</span></span></span><span style="display:flex;"><span><span style="color:#888">        &#34;  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, &#34;
</span></span></span><span style="display:flex;"><span><span style="color:#888">        &#34;%d smallest_snapshot: %d&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#888">        ikey.user_key.ToString().c_str(),
</span></span></span><span style="display:flex;"><span><span style="color:#888">        (int)ikey.sequence, ikey.type, kTypeValue, drop,
</span></span></span><span style="display:flex;"><span><span style="color:#888">        compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key),
</span></span></span><span style="display:flex;"><span><span style="color:#888">        (int)last_sequence_for_key, (int)compact-&gt;smallest_snapshot);
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#579">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#579"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 如果当前数据项不丢弃, 则进行压实落盘
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>drop) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 如有必要则创建新的 output file
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (compact<span style="color:#333">-&gt;</span>builder <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>        status <span style="color:#333">=</span> OpenCompactionOutputFile(compact);
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>          <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (compact<span style="color:#333">-&gt;</span>builder<span style="color:#333">-&gt;</span>NumEntries() <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 如果一个都没写过, input 迭代器又是从小到大遍历,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 所以当前 user key 肯定是最小的
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        compact<span style="color:#333">-&gt;</span>current_output()<span style="color:#333">-&gt;</span>smallest.DecodeFrom(key);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 否则当前 user key 目前就是最大的
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      compact<span style="color:#333">-&gt;</span>current_output()<span style="color:#333">-&gt;</span>largest.DecodeFrom(key);
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 将该 user key 对应的数据项写入 sstable.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// TODO 这里有个地方没看明白:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 如果当前 user key 首次出现, 则
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 上面 last_sequence_for_key 被置为 kMaxSequenceNumber,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 且类型不是 kTypeDeletion, 那当前数据项就不会被 drop, 即使
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 这个数据项实际 sequence number 小于 smallest_snapshot,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 有点矛盾了.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      compact<span style="color:#333">-&gt;</span>builder<span style="color:#333">-&gt;</span>Add(key, input<span style="color:#333">-&gt;</span>value());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 如果 sstable 文件足够大, 则落盘并关闭
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (compact<span style="color:#333">-&gt;</span>builder<span style="color:#333">-&gt;</span>FileSize() <span style="color:#333">&gt;=</span>
</span></span><span style="display:flex;"><span>          compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>MaxOutputFileSize()) {
</span></span><span style="display:flex;"><span>        status <span style="color:#333">=</span> FinishCompactionOutputFile(compact, input);
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>          <span style="color:#080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 处理下个 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    input<span style="color:#333">-&gt;</span>Next();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (status.ok() <span style="color:#333">&amp;&amp;</span> shutting_down_.Acquire_Load()) {
</span></span><span style="display:flex;"><span>    status <span style="color:#333">=</span> Status<span style="color:#333">::</span>IOError(<span style="background-color:#fff0f0">&#34;Deleting DB during compaction&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (status.ok() <span style="color:#333">&amp;&amp;</span> compact<span style="color:#333">-&gt;</span>builder <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>    status <span style="color:#333">=</span> FinishCompactionOutputFile(compact, input);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (status.ok()) {
</span></span><span style="display:flex;"><span>    status <span style="color:#333">=</span> input<span style="color:#333">-&gt;</span>status();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">delete</span> input;
</span></span><span style="display:flex;"><span>  input <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  CompactionStats stats;
</span></span><span style="display:flex;"><span>  stats.micros <span style="color:#333">=</span> env_<span style="color:#333">-&gt;</span>NowMicros() <span style="color:#333">-</span> start_micros <span style="color:#333">-</span> imm_micros;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> which <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; which <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">2</span>; which<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>num_input_files(which); i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      stats.bytes_read <span style="color:#333">+=</span> compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>input(which, i)<span style="color:#333">-&gt;</span>file_size;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">for</span> (size_t i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> compact<span style="color:#333">-&gt;</span>outputs.size(); i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>    stats.bytes_written <span style="color:#333">+=</span> compact<span style="color:#333">-&gt;</span>outputs[i].file_size;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mutex_.Lock();
</span></span><span style="display:flex;"><span>  stats_[compact<span style="color:#333">-&gt;</span>compaction<span style="color:#333">-&gt;</span>level() <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>].Add(stats);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (status.ok()) {
</span></span><span style="display:flex;"><span>    status <span style="color:#333">=</span> InstallCompactionResults(compact);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>status.ok()) {
</span></span><span style="display:flex;"><span>    RecordBackgroundError(status);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  VersionSet<span style="color:#333">::</span>LevelSummaryStorage tmp;
</span></span><span style="display:flex;"><span>  Log(options_.info_log,
</span></span><span style="display:flex;"><span>      <span style="background-color:#fff0f0">&#34;compacted to: %s&#34;</span>, versions_<span style="color:#333">-&gt;</span>LevelSummary(<span style="color:#333">&amp;</span>tmp));
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际的压实工作其实很简单，对于待压实的文件构建一个统一的迭代器，从小到大顺序访问（还记得InternalKey的构造吗，该构造可以保证我们总是最先读到最新的数据),不断的将数据写入到新的文件中。注意，如果遇到遇到<strong>标记删除</strong>的数据,不应该马上<code>drop</code>，而是应该确定上层没有该key的数据了，再<code>drop</code>(因为如果<code>drop</code>了，会导致以后读取该数据，可能读到上层的数据，从而导致一个本该被删除的数据又被读到了)</p>
<p>后面每次把最新的数据写到新的文件中。下面两种情况需要将新生成的文件落盘。</p>
<ol>
<li>文件到达阈值</li>
<li>文件与grandparent重叠的byte数到达阈值（减少后续的<code>Compact</code>压力）</li>
</ol>
<p>最终完成压实的操作。</p>
<h2 id="version">Version</h2>
<p><code>LevelDB</code>的最后，我们介绍一下版本，版本可以认为是<code>LevelDB</code>管理文件的一个接口，如果你想要获取文件，获取某一Level的文件，你都需要通过Version。</p>
<p><code>LevelDB</code>的版本由三部分组成</p>
<ol>
<li>VersionSet 负责维护所有的Version</li>
<li>Version 一个确定的版本，可以认为是数据库的Snapshot。</li>
<li>VersionEdit 增量更新的版本，当完成增量更新后，VersionEdit就会变为Version。</li>
</ol>
<p>我们先看一下Version</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Version</span> {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  VersionSet<span style="color:#333">*</span> vset_;           
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 接下来两个指针使得 Version 可以构成双向循环链表
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 指向链表中下个 version 的指针
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Version<span style="color:#333">*</span> next_;              
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 指向链表中前个 version 的指针
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Version<span style="color:#333">*</span> prev_;              
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 该 version 的活跃引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">int</span> refs_;                    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 核心成员, 该成员保存了当前最新的 level 架构信息,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 即 db 每个 level 的文件元数据链表
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span>FileMetaData<span style="color:#333">*&gt;</span> files_[config<span style="color:#333">::</span>kNumLevels];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 基于查询统计而得出的下个待压实的文件及其所在的 level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  FileMetaData<span style="color:#333">*</span> file_to_compact_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> file_to_compact_level_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 基于存储比值计算的压实分数,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 小于 1 意味着未到上限, 压实不是很需要.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 由 Finalize() 计算.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">double</span> compaction_score_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 基于存储比值而得出的下个待压实的 level.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 由 Finalize() 计算.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">int</span> compaction_level_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>我们可以看到<code>Version</code>最重要的是保存着每一层的文件元信息，通过这些信息，我们可以获得每一个<code>Level</code>所拥有的文件。这也就是Version最重要的作用，确定Level的格式。</p>
<p>我们再看一下<code>VersionSet</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">VersionSet</span> {
</span></span><span style="display:flex;"><span>  Env<span style="color:#333">*</span> <span style="color:#080;font-weight:bold">const</span> env_;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> std<span style="color:#333">::</span>string dbname_;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> Options<span style="color:#333">*</span> <span style="color:#080;font-weight:bold">const</span> options_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 每次用户进行查询操作的时候(DBImpl::Get())可能需要去查询
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 磁盘上的文件, 这就要求有个缓存功能来加速.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 下面这个成员会缓存 sstable 文件对应的 Table 实例, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 用于加速用户的查询, 否则每次读文件解析
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 就很慢了. 目前在用的缓存策略是 LRU.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 该变量实际值来自 DBImpl 实例, 具体见 VersionSet 构造方法.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  TableCache<span style="color:#333">*</span> <span style="color:#080;font-weight:bold">const</span> table_cache_;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">const</span> InternalKeyComparator icmp_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">uint64_t</span> next_file_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">uint64_t</span> manifest_file_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 记录最近一次更新操作对应的序列号(逐一递增, WriteBatch 包含一批更新操作, 每个更新操作都会有一个序列号).
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 具体修改建 DbImpl::Write 方法
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">uint64_t</span> last_sequence_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">uint64_t</span> log_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">uint64_t</span> prev_log_number_;  <span style="color:#888">// 0 or backing store for memtable being compacted
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Opened lazily
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 当前 MANIFEST 文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  WritableFile<span style="color:#333">*</span> descriptor_file_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// MANIFEST 文件格式同 log 文件, 所以写入方法就复用了.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 其每条日志就是一个序列化后的 VersionEdit.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  log<span style="color:#333">::</span>Writer<span style="color:#333">*</span> descriptor_log_; 
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 属于该 VersionSet 的 Version 都会被维护到一个双向循环链表中,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 而且新加入的 Version 都会插入到 dummy_versions_ 前面. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// dummy_versions_.next_ 默认指向自己(具体见 Version 构造函数)后续指向最老的 version.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Version dummy_versions_; 
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 指向当前 Version == dummy_versions_.prev_
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Version<span style="color:#333">*</span> current_;       
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Per-level key at which the next compaction at that level should start.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// Either an empty string, or a valid InternalKey.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 记录了每个 level 各自对应的下次压实的起始 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>string compact_pointer_[config<span style="color:#333">::</span>kNumLevels];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// No copying allowed
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  VersionSet(<span style="color:#080;font-weight:bold">const</span> VersionSet<span style="color:#333">&amp;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">=</span>(<span style="color:#080;font-weight:bold">const</span> VersionSet<span style="color:#333">&amp;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以看到VersionSet保存着整个数据库的元信息，例如下一个文件的<code>number</code>，最新的<code>sequence</code>&hellip;,同时也维护者最新的<code>Version</code>，我们可以将其视作数据库的元信息。</p>
<p>我们再看一下<code>VersionEdit</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">VersionEdit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#080;font-weight:bold">private</span><span style="color:#333">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">friend</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">VersionSet</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">typedef</span> std<span style="color:#333">::</span>set<span style="color:#333">&lt;</span> std<span style="color:#333">::</span>pair<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span>, <span style="color:#339;font-weight:bold">uint64_t</span><span style="color:#333">&gt;</span> <span style="color:#333">&gt;</span> DeletedFileSet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 比较器名称
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>string comparator_; <span style="color:#888">// comparator name
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">uint64_t</span> log_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">uint64_t</span> prev_log_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 下个 MANIFEST 文件编号, 从 1 开始
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">uint64_t</span> next_file_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 下个写操作的序列号
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  SequenceNumber last_sequence_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_comparator_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_log_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_prev_log_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_next_file_number_;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">bool</span> has_last_sequence_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 记录每个 level 下次压实的起始 key
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span> std<span style="color:#333">::</span>pair<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span>, InternalKey<span style="color:#333">&gt;</span> <span style="color:#333">&gt;</span> compact_pointers_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 保存从当前 level 架构要删除的一个文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  DeletedFileSet deleted_files_;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 保存要新增到当前 level 架构中的文件(注意第二个参数不是指针类型)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span> std<span style="color:#333">::</span>pair<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span>, FileMetaData<span style="color:#333">&gt;</span> <span style="color:#333">&gt;</span> new_files_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>VersionEdit</code>存储着目前数据库的增量信息，可以认为是实时的<code>Version</code></p>
<p>我们从数据库的<code>Open</code>过程，来将这三个类串联起来。<code>Open</code>的过程主要还是<code>Recover</code>完成的，我们来看<code>Recover</code>的代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>Status DBImpl<span style="color:#333">::</span>Recover(VersionEdit<span style="color:#333">*</span> edit, <span style="color:#339;font-weight:bold">bool</span> <span style="color:#333">*</span>save_manifest) {
</span></span><span style="display:flex;"><span>  mutex_.AssertHeld();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Ignore error from CreateDir since the creation of the DB is
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// committed only when the descriptor is created, and this directory
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// may already exist from a previous failed creation attempt.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 创建数据库目录(一个目录代表一个数据库)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  env_<span style="color:#333">-&gt;</span>CreateDir(dbname_);
</span></span><span style="display:flex;"><span>  assert(db_lock_ <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 锁定该目录
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  Status s <span style="color:#333">=</span> env_<span style="color:#333">-&gt;</span>LockFile(LockFileName(dbname_), <span style="color:#333">&amp;</span>db_lock_);
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>s.ok()) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> s;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 如果 CURRENT 文件(记录当前 MENIFEST 文件名称)不存在则创建之
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>env_<span style="color:#333">-&gt;</span>FileExists(CurrentFileName(dbname_))) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (options_.create_if_missing) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 创建之
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      s <span style="color:#333">=</span> NewDB();
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>s.ok()) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">return</span> s;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">return</span> Status<span style="color:#333">::</span>InvalidArgument(
</span></span><span style="display:flex;"><span>          dbname_, <span style="background-color:#fff0f0">&#34;does not exist (create_if_missing is false)&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (options_.error_if_exists) {
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">return</span> Status<span style="color:#333">::</span>InvalidArgument(
</span></span><span style="display:flex;"><span>          dbname_, <span style="background-color:#fff0f0">&#34;exists (error_if_exists is true)&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#888">//....
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><p>首先<code>Recover</code>会将目录锁定起来，如果目录下没有CURRENT文件，那么该数据库为新建立的，新建一个数据库即可。</p>
<p>在这里<code>CURRENT</code>文件记录着最新的<code>MANIFEST</code>文件名。</p>
<div style="text-align: center">
<img src="/pic/levelDB/current-file.png"/>
</div>
<p>在得到了最新的<code>MANIFEST</code>文件名后，我们就可以调用<code>VersionSet::Recover</code>读取<code>MANIFEST</code>文件</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>  Builder <span style="color:#06b;font-weight:bold">builder</span>(<span style="color:#080;font-weight:bold">this</span>, current_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    LogReporter reporter;
</span></span><span style="display:flex;"><span>    reporter.status <span style="color:#333">=</span> <span style="color:#333">&amp;</span>s;
</span></span><span style="display:flex;"><span>    log<span style="color:#333">::</span>Reader reader(file, <span style="color:#333">&amp;</span>reporter, <span style="color:#007020">true</span><span style="color:#888">/*checksum*/</span>, <span style="color:#00d;font-weight:bold">0</span><span style="color:#888">/*initial_offset*/</span>);
</span></span><span style="display:flex;"><span>    Slice record;
</span></span><span style="display:flex;"><span>    std<span style="color:#333">::</span>string scratch;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 循环读取 MANIFEST 文件日志, 每一行日志就是一个 VersionEdit
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">while</span> (reader.ReadRecord(<span style="color:#333">&amp;</span>record, <span style="color:#333">&amp;</span>scratch) <span style="color:#333">&amp;&amp;</span> s.ok()) {
</span></span><span style="display:flex;"><span>      VersionEdit edit;
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 将 record 反序列化为 version_edit
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      s <span style="color:#333">=</span> edit.DecodeFrom(record);
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (s.ok()) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">if</span> (edit.has_comparator_ <span style="color:#333">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            edit.comparator_ <span style="color:#333">!=</span> icmp_.user_comparator()<span style="color:#333">-&gt;</span>Name()) {
</span></span><span style="display:flex;"><span>          s <span style="color:#333">=</span> Status<span style="color:#333">::</span>InvalidArgument(
</span></span><span style="display:flex;"><span>              edit.comparator_ <span style="color:#333">+</span> <span style="background-color:#fff0f0">&#34; does not match existing comparator &#34;</span>,
</span></span><span style="display:flex;"><span>              icmp_.user_comparator()<span style="color:#333">-&gt;</span>Name());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 将 VersionEdit 保存到 VersionSet 的 builder 中, 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 后者可以一次性将这些文件变更与当前 Version 合并构成新 version.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (s.ok()) {
</span></span><span style="display:flex;"><span>        builder.Apply(<span style="color:#333">&amp;</span>edit);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (edit.has_log_number_) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 保存最新的日志文件名, 越后面的日志(record)记录的日志文件名越新
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        log_number <span style="color:#333">=</span> edit.log_number_;
</span></span><span style="display:flex;"><span>        have_log_number <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (edit.has_prev_log_number_) {
</span></span><span style="display:flex;"><span>        prev_log_number <span style="color:#333">=</span> edit.prev_log_number_;
</span></span><span style="display:flex;"><span>        have_prev_log_number <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (edit.has_next_file_number_) {
</span></span><span style="display:flex;"><span>        next_file <span style="color:#333">=</span> edit.next_file_number_;
</span></span><span style="display:flex;"><span>        have_next_file <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">if</span> (edit.has_last_sequence_) {
</span></span><span style="display:flex;"><span>        last_sequence <span style="color:#333">=</span> edit.last_sequence_;
</span></span><span style="display:flex;"><span>        have_last_sequence <span style="color:#333">=</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p><code>Manifest</code>的文件格式与LOG文件保持一致，LOG文件的具体格式如下图所示。</p>
<div style="text-align: center">
<img src="/pic/levelDB/log-format.png"/>
</div>
<p>而里面的data则是<code>VersionEdit</code>的序列化形式（<strong>里面的tag可能出现多次</strong>）。</p>
<div style="text-align: center">
<img src="/pic/levelDB/version-edit.png"/>
</div>
<p>在反序列化<code>VersionEdit</code>后，我们可以将所有的<code>VersionEdit</code>合并给一个<code>Version</code>,本质上就是把<code>VersionEdit</code>的新增文件以及删除文件，compact_pointer,和现有的<code>Version</code>进行合并。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">Apply</span>(VersionEdit<span style="color:#333">*</span> edit) {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 更新压实指针信息
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将 edit 中保存的每一层下次压实起始 key 复制到 VersionSet 中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (size_t i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> edit<span style="color:#333">-&gt;</span>compact_pointers_.size(); i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">int</span> level <span style="color:#333">=</span> edit<span style="color:#333">-&gt;</span>compact_pointers_[i].first;
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 与下面新增和删除不同, 这里直接修改 vset
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      vset_<span style="color:#333">-&gt;</span>compact_pointer_[level] <span style="color:#333">=</span>
</span></span><span style="display:flex;"><span>          edit<span style="color:#333">-&gt;</span>compact_pointers_[i].second.Encode().ToString();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 删除文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将 edit 中保存的待删除文件集合导入到 levels_[].deleted_files 中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">const</span> VersionEdit<span style="color:#333">::</span>DeletedFileSet<span style="color:#333">&amp;</span> del <span style="color:#333">=</span> edit<span style="color:#333">-&gt;</span>deleted_files_;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">for</span> (VersionEdit<span style="color:#333">::</span>DeletedFileSet<span style="color:#333">::</span>const_iterator iter <span style="color:#333">=</span> del.begin();
</span></span><span style="display:flex;"><span>         iter <span style="color:#333">!=</span> del.end();
</span></span><span style="display:flex;"><span>         <span style="color:#333">++</span>iter) {
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">int</span> level <span style="color:#333">=</span> iter<span style="color:#333">-&gt;</span>first;
</span></span><span style="display:flex;"><span>      <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">uint64_t</span> number <span style="color:#333">=</span> iter<span style="color:#333">-&gt;</span>second;
</span></span><span style="display:flex;"><span>      levels_[level].deleted_files.insert(number);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 添加新文件
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 将 edit 中保存的新增文件集合导入到 levels_[].added_files 中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (size_t i <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; i <span style="color:#333">&lt;</span> edit<span style="color:#333">-&gt;</span>new_files_.size(); i<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// pair 第一个参数为 level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">int</span> level <span style="color:#333">=</span> edit<span style="color:#333">-&gt;</span>new_files_[i].first;
</span></span><span style="display:flex;"><span>      <span style="color:#888">// pair 第二个参数为 FileMetaData
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      FileMetaData<span style="color:#333">*</span> f <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> FileMetaData(edit<span style="color:#333">-&gt;</span>new_files_[i].second);
</span></span><span style="display:flex;"><span>      f<span style="color:#333">-&gt;</span>refs <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// leveldb 针对经过一定查询次数的文件进行自动压实. 我们假设:
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//    (1)一次查询消耗 10ms
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//    (2)写或者读 1MB 数据消耗 10ms(即 100MB/s, 这是一般磁盘 IO 速度)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//    (3)1MB 数据的压实做了 25MB 数据的 IO 工作: 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//        从 level-L 读取了 1MB
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//        从 level-(L+1) 读取了 10-12MB(边界可能没有对齐)重叠数据
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">//        将压实后的 10-12MB 数据写入到 level-(L+1)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 基于上述假设, 我们可以得出, 执行 25 次查询消耗的时间与压实 1MB 数据
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 的时间相同, 都是 250ms. 也就是说, 一次查询大约相当于压实 40KB (=1MB/25)数据.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 现实可能没这么理想, 我们保守一些, 假设每次查询大约相当于压实 16KB 数据, 这样
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 我们就可以得出压实之前一个文件被允许查询的次数 == [文件字节数/16KB],
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 一个文件最大 2MB, 则在压实前最多允许查询 128 次, 超过次数会触发压实操作.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">=</span> (f<span style="color:#333">-&gt;</span>file_size <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">16384</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 如果允许查询次数小于 100, 则按 100 次处理. 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">if</span> (f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">100</span>) f<span style="color:#333">-&gt;</span>allowed_seeks <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// todo 一个文件会同时出现在删除列表和新增列表? 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      levels_[level].deleted_files.erase(f<span style="color:#333">-&gt;</span>number);
</span></span><span style="display:flex;"><span>      levels_[level].added_files<span style="color:#333">-&gt;</span>insert(f);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// 将当前 version 与 builder 保存的新增文件按序合并
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 追加到新 Version v 中.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">SaveTo</span>(Version<span style="color:#333">*</span> v) {
</span></span><span style="display:flex;"><span>    BySmallestKey cmp;
</span></span><span style="display:flex;"><span>    cmp.internal_comparator <span style="color:#333">=</span> <span style="color:#333">&amp;</span>vset_<span style="color:#333">-&gt;</span>icmp_;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// 从低到高将当前 Version base_ 每个 level 文件列表和 Builder::levels_ 每个对应 level
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#888">// 新增文件列表合并, 并保存到 Version v 对应 level 中.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> level <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; level <span style="color:#333">&lt;</span> config<span style="color:#333">::</span>kNumLevels; level<span style="color:#333">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 把新加的文件和已有文件进行合并, 丢弃已被删除的文件, 最终结果保存到 *v.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Version base_ 中 level-L 对应的文件列表
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">const</span> std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span>FileMetaData<span style="color:#333">*&gt;&amp;</span> base_files <span style="color:#333">=</span> base_<span style="color:#333">-&gt;</span>files_[level];
</span></span><span style="display:flex;"><span>      std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span>FileMetaData<span style="color:#333">*&gt;::</span>const_iterator base_iter <span style="color:#333">=</span> base_files.begin();
</span></span><span style="display:flex;"><span>      std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span>FileMetaData<span style="color:#333">*&gt;::</span>const_iterator base_end <span style="color:#333">=</span> base_files.end();
</span></span><span style="display:flex;"><span>      <span style="color:#888">// builder 保存的 level-L 对应的新增文件集合
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">const</span> FileSet<span style="color:#333">*</span> added <span style="color:#333">=</span> levels_[level].added_files;
</span></span><span style="display:flex;"><span>      v<span style="color:#333">-&gt;</span>files_[level].reserve(base_files.size() <span style="color:#333">+</span> added<span style="color:#333">-&gt;</span>size());
</span></span><span style="display:flex;"><span>      <span style="color:#888">// 下面两个循环按照文件包含的 key 从小到大顺序合并前述两个文件列表.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// (具体逻辑就是将两个有序列表合并的过程.)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">for</span> (FileSet<span style="color:#333">::</span>const_iterator added_iter <span style="color:#333">=</span> added<span style="color:#333">-&gt;</span>begin();
</span></span><span style="display:flex;"><span>           added_iter <span style="color:#333">!=</span> added<span style="color:#333">-&gt;</span>end();
</span></span><span style="display:flex;"><span>           <span style="color:#333">++</span>added_iter) {
</span></span><span style="display:flex;"><span>        <span style="color:#888">// 针对 builder 中每个新增文件 *added_iter,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 从 base_ 对应 level 寻找第一个大于它的文件,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 然后将这个文件之前的文件(builder 里文件列表从小到大有序)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 都追加到 v 中.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 寻找过程采用 BySmallestKey 比较器(这个抽象极好).
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">for</span> (std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span>FileMetaData<span style="color:#333">*&gt;::</span>const_iterator bpos
</span></span><span style="display:flex;"><span>                 <span style="color:#333">=</span> std<span style="color:#333">::</span>upper_bound(base_iter, base_end, <span style="color:#333">*</span>added_iter, cmp);
</span></span><span style="display:flex;"><span>             base_iter <span style="color:#333">!=</span> bpos; <span style="color:#888">// 如果相等说明 builder 全部文件都比 added_iter 大
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>             <span style="color:#333">++</span>base_iter) {
</span></span><span style="display:flex;"><span>          <span style="color:#888">// bpos 位置处文件小于 added_iter,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>          <span style="color:#888">// 将其追加到 Version v 对应 level 的文件列表中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>          MaybeAddFile(v, level, <span style="color:#333">*</span>base_iter);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#888">// builder 中小于 added_iter 的文件都追加过了,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#888">// 将 *added_iter 追加到 Version v 的对应 level 的文件列表中.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        MaybeAddFile(v, level, <span style="color:#333">*</span>added_iter);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#888">// Add remaining base files
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#888">// 将 Version base_ 中 level-L 对应的文件列表剩余的文件追加到 Version v 的对应 level-L 的文件列表中
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>      <span style="color:#080;font-weight:bold">for</span> (; base_iter <span style="color:#333">!=</span> base_end; <span style="color:#333">++</span>base_iter) {
</span></span><span style="display:flex;"><span>        MaybeAddFile(v, level, <span style="color:#333">*</span>base_iter);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>然后将新生成的<code>Version</code>加入到<code>VersionSet</code>中，并设置为<code>current</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">void</span> VersionSet<span style="color:#333">::</span>AppendVersion(Version<span style="color:#333">*</span> v) {
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Make &#34;v&#34; current
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  assert(v<span style="color:#333">-&gt;</span>refs_ <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>  assert(v <span style="color:#333">!=</span> current_);
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (current_ <span style="color:#333">!=</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
</span></span><span style="display:flex;"><span>    current_<span style="color:#333">-&gt;</span>Unref();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  current_ <span style="color:#333">=</span> v;
</span></span><span style="display:flex;"><span>  <span style="color:#888">// current_ 引用了 v, 将 v 引用计数加一
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  v<span style="color:#333">-&gt;</span>Ref();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">// Append to linked list
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  <span style="color:#888">// 将 v 加入到双向循环链表中, 新插入的永远是 dummy_versions_ 的前驱.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>  v<span style="color:#333">-&gt;</span>prev_ <span style="color:#333">=</span> dummy_versions_.prev_;
</span></span><span style="display:flex;"><span>  v<span style="color:#333">-&gt;</span>next_ <span style="color:#333">=</span> <span style="color:#333">&amp;</span>dummy_versions_;
</span></span><span style="display:flex;"><span>  v<span style="color:#333">-&gt;</span>prev_<span style="color:#333">-&gt;</span>next_ <span style="color:#333">=</span> v;
</span></span><span style="display:flex;"><span>  v<span style="color:#333">-&gt;</span>next_<span style="color:#333">-&gt;</span>prev_ <span style="color:#333">=</span> v;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果你想知道在<code>Compact</code>时，是如何生成新的<code>Version</code>与新的<code>MANIFEST</code>,那么你可以看一下<code>VersionSet::LogAndApply</code>的实现。</p>
<h3 id="overview">Overview</h3>
<p>本文介绍了LevelDB的Compact以及版本。这篇文章并没有将所有的细节都写出来，如果你想要详细了解，我推荐你还是需要去读相关代码。这篇文章更侧重描写出LevelDB的大概轮廓，以及一些比较重要的细节。希望对你理解LevelDB相关代码有所帮助。</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/database/">database</a>
<a href="/categories/leveldb/">leveldb</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
