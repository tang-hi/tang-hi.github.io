<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>Return Value Optimization | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="这篇文章是因为在油管上看了Jon Kalb在2018年的CppCon上做的演讲，深受启发，决定换一个视角来审视C&#43;&#43;的RVO机制。">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="Return Value Optimization" />
<meta property="og:description" content="这篇文章是因为在油管上看了Jon Kalb在2018年的CppCon上做的演讲，深受启发，决定换一个视角来审视C&#43;&#43;的RVO机制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/c&#43;&#43;/rvo/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-01-15T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Return Value Optimization"/>
<meta name="twitter:description" content="这篇文章是因为在油管上看了Jon Kalb在2018年的CppCon上做的演讲，深受启发，决定换一个视角来审视C&#43;&#43;的RVO机制。"/>

<meta itemprop="name" content="Return Value Optimization">
<meta itemprop="description" content="这篇文章是因为在油管上看了Jon Kalb在2018年的CppCon上做的演讲，深受启发，决定换一个视角来审视C&#43;&#43;的RVO机制。"><meta itemprop="datePublished" content="2023-01-15T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-01-15T00:00:00+00:00" />
<meta itemprop="wordCount" content="807">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">15</span>
<span class="rest">Jan 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">Return Value Optimization</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;4&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;807&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>之所以写这篇文章是因为在油管上看了Jon Kalb在2018年的CppCon上做的<a href="https://www.youtube.com/watch?v=IZbL-RGr_mk&amp;list=PLhPcHQ7xzdwcG9OFqP4Xg_7nn6RGVFsw9&amp;index=1" target="_blank">演讲</a>，深受启发，决定换一个视角来审视C++的RVO机制。</p>
<h3 id="1-calling-conventions">1. calling conventions</h3>
<h4 id="11-返回值为int-float">1.1 返回值为int, float&hellip;.</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">simple</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">+</span> simple();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述的代码经过编译后得到的汇编代码如下所示</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>simple():
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        mov     eax, 1
</span></span><span style="display:flex;"><span>        pop     rbp
</span></span><span style="display:flex;"><span>        ret
</span></span><span style="display:flex;"><span>main:
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        call    simple()
</span></span><span style="display:flex;"><span>        add     eax, 1
</span></span><span style="display:flex;"><span>        pop     rbp
</span></span><span style="display:flex;"><span>        ret
</span></span></code></pre></div><p>因为是RVO，所以我们只关心 <strong>return value</strong>，我们可以发现simple中的一条汇编语句<code>move eax 1</code>,这条语句对应于simple中的<code>return 1;</code>也就是说在C++中，我们会将需要返回的值存在<code>rax</code>寄存器中。当然前提是rax可以放下需要返回的值。</p>
<h4 id="12-返回值为struct类型">1.2 返回值为struct类型</h4>
<p>如果返回值为struct类型，也就是rax不一定可以放的下该类型应该怎么办？</p>
<p>观察下面的代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">BigObject</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#339;font-weight:bold">int</span> data[<span style="color:#00d;font-weight:bold">6</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BigObject <span style="color:#06b;font-weight:bold">big</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> BigObject{<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">2</span>,<span style="color:#00d;font-weight:bold">3</span>,<span style="color:#00d;font-weight:bold">5</span>,<span style="color:#00d;font-weight:bold">6</span>,<span style="color:#00d;font-weight:bold">7</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	BigObject bo <span style="color:#333">=</span> big();
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该代码经过编译后得到的汇编代码如下所示</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>big():
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        mov     QWORD PTR [rbp-8], rdi
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax], 1
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax+4], 2
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax+8], 3
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax+12], 5
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax+16], 6
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rax+20], 7
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp-8]
</span></span><span style="display:flex;"><span>        pop     rbp
</span></span><span style="display:flex;"><span>        ret
</span></span><span style="display:flex;"><span>main:
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        sub     rsp, 32
</span></span><span style="display:flex;"><span>        lea     rax, [rbp-32]
</span></span><span style="display:flex;"><span>        mov     rdi, rax
</span></span><span style="display:flex;"><span>        call    big()
</span></span><span style="display:flex;"><span>        mov     eax, 0
</span></span><span style="display:flex;"><span>        leave
</span></span><span style="display:flex;"><span>        ret
</span></span></code></pre></div><p>我们可以看到仍旧是将返回值存入<code>rax</code>中，只不过这里的<code>rax</code>更像是一个指针，通过offset将对应的值存入<code>mov     DWORD PTR [rax+4], 2</code></p>
<p>整个调用过程我们用两张图来进行总结</p>
<p><figure>
  <img src="/pic/stack.png" alt="simple"  />
</figure></p>
<p><figure>
  <img src="/pic/stack-big.png" alt="big-call"  />
</figure></p>
<p>整个调用过程就算不太了解也没有关系，我们只需要记住函数的返回值一定是存在<code>rax</code>中，区别在于是把<code>rax</code>当作int这种标量，还是当作指针对待。</p>
<h3 id="2-使用rax实现rvo">2 使用RAX实现RVO</h3>
<p>RVO实际上就是在函数返回时，将原本需要进行的拷贝操作省略掉，那么怎么实现呢？通过上面的描述，我们知道返回值实际都在<code>rax</code>中，那么只要我们在调用函数前，自己开辟一块空间（在栈帧中），然后将这块空间的地址给到 <code>rax</code>，等到函数返回时，我们就无须对返回的临时变量进行拷贝，因为返回值已经在<code>rax</code>（我们开辟的空间）中了，我们可以直接使用。</p>
<p>还是用一张图来总结这个过程。</p>
<p><figure>
  <img src="/pic/stack-summary.png" alt="summary"  />
</figure></p>
<h3 id="3rvo-的适用场景">3.RVO 的适用场景</h3>
<p>当粗略的了解了RVO的实现原理后，我们便可以，从另一种视角对RVO的适用场景进行审视。</p>
<h4 id="31-unamed-rvo-white_check_mark">3.1 unamed rvo :white_check_mark:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">URVO</span>() { <span style="color:#080;font-weight:bold">return</span> Foo(); }
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> URVO();
</span></span></code></pre></div><p>这种场景下，因为整个返回值都是临时变量，所以我们可以直接在开辟的空间中进行构造，无需拷贝。因此这种场景下，RVO是可以被使用的。</p>
<h4 id="31-named-rvo-white_check_mark">3.1 named rvo :white_check_mark:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">NRVO</span>() {
</span></span><span style="display:flex;"><span>  Foo foo;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> foo;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> NRVO();
</span></span></code></pre></div><p>这种场景下，返回值是一个局部变量，但是我们可以在开辟的空间中直接对局部变量进行构造。因此这种场景下，RVO是可以被使用的。</p>
<h4 id="33-named-rvo-with-compile-time-condition-white_check_mark">3.3 named rvo with compile-time condition :white_check_mark:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">NRVO_Compile_BRANCH</span>(<span style="color:#339;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>  Foo foo;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (x <span style="color:#333">%</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> foo;
</span></span><span style="display:flex;"><span>  } <span style="color:#080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> foo;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> NRVO_Compile_BRANCH();
</span></span></code></pre></div><p>这种场景下，返回值是一个局部变量，并且不论条件变量如何，我们都明确只返回那一个局部变量(编译期即可确定)，因此我们可以直接在开辟的空间中构造局部变量，rvo适用。</p>
<h4 id="34-named-rvo-with-run-time-condition-x">3.4 named rvo with run-time condition :x:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">NRVO_RUNTIME_BRANCH</span>(<span style="color:#339;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>  Foo foo, foo1;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">if</span> (x <span style="color:#333">%</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> foo;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> foo1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> NRVO_RUNTIME_BRANCH();
</span></span></code></pre></div><p>这种场景下，我们有两个局部变量，且这两个局部变量都有可能成为返回值，只有在runtime我们才能确定，因此我们无法直接在开辟的空间中进行构造（因为只有运行到return时，我们才知道那一个是返回值，而这时候该值早就已经构造好了）,只能通过拷贝构造函数进行生成，rvo不适用。</p>
<h4 id="35-return-global-variable-white_check_mark">3.5 return global variable :white_check_mark:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">Global_FOO</span>() { <span style="color:#080;font-weight:bold">return</span> global_foo; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> Global_FOO();
</span></span></code></pre></div><p>尽管很多博客文章都说这种场景下，不会使用RVO，但是经过测试结果显示，虽然我们返回的是全局变量，该变量早就已经构造完成，有它专属的物理地址，但是我们依然可以在返回地址处直接使用拷贝构造函数进行生成。rvo适用。</p>
<p>以下是我做的实验</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>  Foo() <span style="color:#333">:</span> data(<span style="color:#00d;font-weight:bold">0</span>), id(<span style="color:#333">++</span>version) {
</span></span><span style="display:flex;"><span>    <span style="color:#333">++</span>object_create;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo ctor, version :&#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo(<span style="color:#080;font-weight:bold">const</span> Foo <span style="color:#333">&amp;</span>rhs) <span style="color:#333">:</span> data(rhs.data), id(<span style="color:#333">++</span>version), aaaa(rhs.aaaa) {
</span></span><span style="display:flex;"><span>    <span style="color:#333">++</span>object_create;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo copy ctor, version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo <span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">operator</span><span style="color:#333">=</span>(<span style="color:#080;font-weight:bold">const</span> Foo <span style="color:#333">&amp;</span>rhs) {
</span></span><span style="display:flex;"><span>    data <span style="color:#333">=</span> rhs.data;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo copy assign version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#333">~</span>Foo() { cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo destory version: &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/* data */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> id;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo global_foo;
</span></span><span style="display:flex;"><span>Foo foo1 <span style="color:#333">=</span> Global_FOO();
</span></span><span style="display:flex;"><span><span style="color:#333">---------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span>g<span style="color:#333">++</span> <span style="color:#333">-</span>o enable <span style="color:#333">-</span>O0 <span style="color:#333">-</span>std<span style="color:#333">=</span>c<span style="color:#333">++</span><span style="color:#00d;font-weight:bold">98</span> <span style="color:#333">&amp;</span> .<span style="color:#333">/</span>enable
</span></span><span style="display:flex;"><span>Foo copy ctor, <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-&gt;</span> <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>Foo destory <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>create <span style="color:#00d;font-weight:bold">1</span> objects
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g<span style="color:#333">++</span> <span style="color:#333">-</span>o disable <span style="color:#333">-</span>O0 <span style="color:#333">-</span>std<span style="color:#333">=</span>c<span style="color:#333">++</span><span style="color:#00d;font-weight:bold">98</span> <span style="color:#333">-</span>fno<span style="color:#333">-</span>elide<span style="color:#333">-</span>constructors <span style="color:#333">&amp;</span> .<span style="color:#333">/</span>disable
</span></span><span style="display:flex;"><span>Foo copy ctor, <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-&gt;</span> <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>Foo copy ctor, <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-&gt;</span> <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>Foo destory <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>Foo destory <span style="color:#970;font-weight:bold">version</span>: <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>create <span style="color:#00d;font-weight:bold">2</span> objects
</span></span></code></pre></div><p>可以看到开启rvo时的确少调用一次拷贝构造函数,当然其实这也可以认为是对unamed的rvo优化，而不是global的。</p>
<h4 id="36-return-parameter-white_check_mark">3.6 return parameter :white_check_mark:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">Return_Para</span>(Foo foo) { <span style="color:#080;font-weight:bold">return</span> foo; }
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> Return_Para();
</span></span></code></pre></div><p>这种场景下，和上一个场景很相似，尽管都需要对参数进行一次拷贝，但是RVO可以在返回时进行优化直接拷贝到新开辟的空间中，从而相比与禁止RVO少调用一次拷贝构造函数。</p>
<p>这次我们通过汇编代码进行论证</p>
<p>开启RVO的汇编代码</p>
<p><figure>
  <img src="/pic/compiler1.png" alt="开启RVO"  />
</figure></p>
<p><figure>
  <img src="/pic/compiler2.png" alt="开启RVO"  />
</figure></p>
<p>可以看到整个过程中仅仅只调用了一次拷贝构造函数。</p>
<p>关闭RVO的汇编代码</p>
<p><figure>
  <img src="/pic/compiler3.png" alt="closervo"  />
</figure></p>
<p><figure>
  <img src="/pic/compiler4.png" alt="closervo"  />
</figure></p>
<p>可以看到一共调用了两次拷贝构造函数，这证明了RVO确实在发生作用。</p>
<h4 id="37-return-by-move-x">3.7 return by move :x:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo <span style="color:#06b;font-weight:bold">Return_BY_MOVE</span>() {
</span></span><span style="display:flex;"><span>  Foo foo;
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-weight:bold">return</span> std<span style="color:#333">::</span>move(foo);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Foo foo <span style="color:#333">=</span> Return_BY_MOVE();
</span></span></code></pre></div><p>这个没有什么好说的，C++标准不允许，当你使用<strong>std::move</strong>时，会禁用RVO。</p>
<h4 id="38-一个没啥用的发现">3.8 一个没啥用的发现</h4>
<p>当你的class没有自己写拷贝构造函数，并且里面的成员变量都是没有自己定义的拷贝构造函数，这时候开启RVO，编译器甚至不会给你生成拷贝构造函数。</p>
<p>测试代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>  Foo() <span style="color:#333">:</span> data(<span style="color:#00d;font-weight:bold">0</span>), id(<span style="color:#333">++</span>version) {
</span></span><span style="display:flex;"><span>    <span style="color:#333">++</span>object_create;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo ctor, version :&#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888">//   Foo(const Foo &amp;rhs) : data(rhs.data), id(++version) {
</span></span></span><span style="display:flex;"><span><span style="color:#888">//     ++object_create;
</span></span></span><span style="display:flex;"><span><span style="color:#888">//     cout &lt;&lt; &#34;Foo copy ctor, version: &#34; &lt;&lt; rhs.id &lt;&lt; &#34; -&gt; &#34; &lt;&lt; id &lt;&lt; endl;
</span></span></span><span style="display:flex;"><span><span style="color:#888">//   }
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span><span style="color:#888">//   Foo &amp;operator=(const Foo &amp;rhs) {
</span></span></span><span style="display:flex;"><span><span style="color:#888">//     data = rhs.data;
</span></span></span><span style="display:flex;"><span><span style="color:#888">//     cout &lt;&lt; &#34;Foo copy assign version: &#34; &lt;&lt; rhs.id &lt;&lt; &#34; -&gt; &#34; &lt;&lt; id &lt;&lt; endl;
</span></span></span><span style="display:flex;"><span><span style="color:#888">//     return *this;
</span></span></span><span style="display:flex;"><span><span style="color:#888">//   }
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#333">~</span>Foo() { cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo destory version: &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/* data */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> id;
</span></span><span style="display:flex;"><span><span style="color:#888">// std::vector&lt;int&gt; vec;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>};
</span></span></code></pre></div><p>开启RVO生成的汇编代码</p>
<p><figure>
  <img src="/pic/compiler5.png" alt="开启rvo"  />
</figure></p>
<p>可以看到完全就是寄存器和堆栈的运算。</p>
<p>当你关闭RVO，生成的汇编代码</p>
<p><figure>
  <img src="/pic/compiler6.png" alt="closervo"  />
</figure></p>
<p>编译器会为你生成拷贝构造函数，并且被调用。</p>
<p>但如果<strong>你的class没有自己写拷贝构造函数，并且里面的成员变量都是没有自己定义的拷贝构造函数</strong>这两个条件有一个没满足，编译器都会为你生成拷贝构造函数。</p>
<p>总结，RVO只要被开启，当你返回时基本总是会被使用，即直接在开辟的新空间中直接进行生成，从而节省了一次拷贝。但对于某些特殊的情况，例如返回参数，返回全局变量时，对这种对象的拷贝是无法被省略的。</p>
<h3 id="rvo与stdmove">RVO与std::move</h3>
<p>当std::move参与到rvo时，情况又会有点微妙。</p>
<p>先说一个非常一般，并且绝大多数都对的结论，<strong>当class可以被move，那么当你返回时，如果可以直接构造那么直接构造，如果不能，调用移动构造函数</strong></p>
<p>其实用一句话说，你return的值会被当作右值处理，要么使用RVO，要么使用移动构造函数，但也有例外。</p>
<p>我们先看官网文档</p>
<p><figure>
  <img src="/pic/doc.png" alt="doc"  />
</figure></p>
<p>注意这里加粗的意思是说如果我们return的类型和函数申明的返回类型对不上，那么就会把返回值看作左值也就是会调用拷贝构造函数。例如</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>  Foo() <span style="color:#333">:</span> data(<span style="color:#00d;font-weight:bold">0</span>), id(<span style="color:#333">++</span>version) {
</span></span><span style="display:flex;"><span>    <span style="color:#333">++</span>object_create;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo ctor, version :&#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo(<span style="color:#080;font-weight:bold">const</span> Foo <span style="color:#333">&amp;</span>rhs) <span style="color:#333">:</span> data(rhs.data), id(<span style="color:#333">++</span>version), aaaa(rhs.aaaa) {
</span></span><span style="display:flex;"><span>    <span style="color:#333">++</span>object_create;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo copy ctor, version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo(Foo <span style="color:#333">&amp;&amp;</span>rhs) <span style="color:#333">:</span> data{rhs.data}, id{<span style="color:#333">++</span>version} {
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo move ctor, version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo <span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">operator</span><span style="color:#333">=</span>(<span style="color:#080;font-weight:bold">const</span> Foo <span style="color:#333">&amp;</span>rhs) {
</span></span><span style="display:flex;"><span>    data <span style="color:#333">=</span> rhs.data;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo copy assign version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Foo <span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">operator</span><span style="color:#333">=</span>(Foo <span style="color:#333">&amp;&amp;</span>rhs) {
</span></span><span style="display:flex;"><span>    data <span style="color:#333">=</span> rhs.data;
</span></span><span style="display:flex;"><span>    cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo move assign version: &#34;</span> <span style="color:#333">&lt;&lt;</span> rhs.id <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; -&gt; &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#333">*</span><span style="color:#080;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#333">~</span>Foo() { cout <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;Foo destory version: &#34;</span> <span style="color:#333">&lt;&lt;</span> id <span style="color:#333">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888">/* data */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#339;font-weight:bold">int</span> id;
</span></span><span style="display:flex;"><span>  Complex complex;
</span></span><span style="display:flex;"><span>  std<span style="color:#333">::</span>vector<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span><span style="color:#333">&gt;</span> aaaa;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">FOOS</span> <span style="color:#333">:</span> <span style="color:#080;font-weight:bold">public</span> FOO {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOO <span style="color:#06b;font-weight:bold">return_derived</span>() {
</span></span><span style="display:flex;"><span>    FOOS foos;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> foos; <span style="color:#888">// treat is as lvalue
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><p>因为FOOS并不完全是FOO，所以与FOO(FOO &amp;&amp;rhs)对不上，因此会将返回值视作左值，导致RVO，move都无法使用。</p>
<p>至此，我对于RVO的总结就全部完成了。</p>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/c&#43;&#43;/">c&#43;&#43;</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
