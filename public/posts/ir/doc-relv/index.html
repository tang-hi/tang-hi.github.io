<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="UTF-8">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-D5M6G40M25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D5M6G40M25');
</script>
<meta name="baidu-site-verification" content="codeva-vs6hGikUak" />
<title>文本相关性 | Don&#39;t Panic</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.123.7">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="文本相关性是信息检索和自然语言处理中的一个核心问题。在文本相关性中，我们希望能够量化文本之间的相似程度或相关程度，以便有效地处理和组织文本数据。">
<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" /><link rel="stylesheet" href="/css/katex.css" crossorigin="anonymous">
<script defer src="/js/katex.js"  integrity="sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw" crossorigin="anonymous"></script>
<script defer src="/js/auto-render.js" integrity="sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ] }); });
</script>




<meta property="og:title" content="文本相关性" />
<meta property="og:description" content="文本相关性是信息检索和自然语言处理中的一个核心问题。在文本相关性中，我们希望能够量化文本之间的相似程度或相关程度，以便有效地处理和组织文本数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/ir/doc-relv/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-20T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="文本相关性"/>
<meta name="twitter:description" content="文本相关性是信息检索和自然语言处理中的一个核心问题。在文本相关性中，我们希望能够量化文本之间的相似程度或相关程度，以便有效地处理和组织文本数据。"/>

<meta itemprop="name" content="文本相关性">
<meta itemprop="description" content="文本相关性是信息检索和自然语言处理中的一个核心问题。在文本相关性中，我们希望能够量化文本之间的相似程度或相关程度，以便有效地处理和组织文本数据。"><meta itemprop="datePublished" content="2023-02-20T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-02-20T00:00:00+00:00" />
<meta itemprop="wordCount" content="721">
<meta itemprop="keywords" content="" />
</head>
<body>
<header>
<div id="avatar">
<a href="http://localhost:1313/"><img src="/avatar.jpeg" alt="Don&#39;t Panic"></a>
</div>
<div id="titletext">
<h2 id="titleonly"><a href="http://localhost:1313/">Don&#39;t Panic</a></h2>
</div>
<div id="title-social">
<div id="social">
<nav><ul>
<li><a href="https://github.com/tang-hi"><i title="Github" class="icons fab fa-github"></i></a></li>
<li><a href="mailto:tangdhcs@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
<li><a href="https://twitter.com/TangDh"><i title="Twitter" class="icons fab fa-twitter"></i></a></li>
<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id="mainmenu">
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/posts">All Posts</a></li>
<li><a href="/about">About</a></li>
<li><a href="/categories">Categories</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class="post">
<article>
<div class="post-header">
<div class="meta">
<div class="date">
<span class="day">20</span>
<span class="rest">Feb 2023</span>
</div>
</div>
<div class="matter">
<h1 class="title">文本相关性</h1>
<p class="post-meta">
<span class="post-meta">

&nbsp;<i class="fas fa-clock"></i>&nbsp;4&nbsp;minutes


 
&nbsp;| &nbsp;

<i class="fas fa-book"></i>&nbsp;721&nbsp;words




</span>

</p>
</div>
</div>
<div class="markdown">
<p>文本相关性是信息检索和自然语言处理中的一个核心问题。在文本相关性中，我们希望能够量化文本之间的相似程度或相关程度，以便有效地处理和组织文本数据。例如，在搜索引擎中，我们希望通过用户的查询来找到与查询相关的最相关的文档或网页。在文档分类和聚类中，我们希望将相似的文档放在一起，以便更好地管理和分析它们。在文本匹配和相似性匹配中，我们希望找到两个文本之间的相似度，以便评估它们之间的关系。
这篇博客会介绍 <strong>TF-IDF</strong> 以及 <strong>BM25</strong></p>
<h3 id="tf-idf">tf-idf</h3>
<p><strong>tf-idf</strong>（Term Frequency-Inverse Document Frequency）是一种用于评估文档中单词重要性的统计方法，广泛应用于信息检索、自然语言处理等领域。</p>
<p>他的整体公式如下</p>
<p>$$
\text{tf-idf}(t,d,D) = \text{tf}(t,d) \cdot \text{idf}(t,D)
$$</p>
<p>其中，$t$ 是指某个单词(term),$d$ 是指某个文档(document),$D$ 是指整个文档集合。tf 表示单词在文档中的频率(term frequency)。<strong>idf</strong> 表示单词在整个文档集合中的逆文档频率(inverse document frequency)。</p>
<p>它们的计算公式如下:</p>
<p>$$
\text{tf}(t,d) = \frac{f_{t,d}}{\sum_{t&rsquo; \in d} f_{t&rsquo;,d}}
$$</p>
<p>其中，$f_{t,d}$ 是指单词 $t$ 在文档 $d$ 中出现的次数。</p>
<p>$$
\text{idf}(t,D) = \log{\frac{N}{|{d \in D : t \in d}|}}
$$</p>
<p>其中，$N$ 是指整个文档集合中文档的总数，$|{d \in D : t \in d}|$ 是指包含单词 $t$ 的文档数。</p>
<p><strong>tf-idf</strong>考虑了一个单词在文档中的频率以及在整个文档集合中的频率，从而确定它在文档中的重要性。一个单词在某个文档中出现的次数越多，其重要性就越高（即<strong>tf</strong>越高）,但是如果它在整个文集中出现的次数也很多，那么它的重要性就会降低(即<strong>idf</strong>越低)</p>
<h4 id="通过例子深入理解tf-idf">通过例子深入理解<strong>tf-idf</strong></h4>
<p>假设我们有一个包含以下 4 个文档的文档集合:</p>
<blockquote>
<p>Doc 1: the cat in the hat</p>
</blockquote>
<blockquote>
<p>Doc 2: the rat in the hat</p>
</blockquote>
<blockquote>
<p>Doc 3: the cat and the rat</p>
</blockquote>
<blockquote>
<p>Doc 4: the cat sat on the hat</p>
</blockquote>
<p>现在，我们想要计算单词 &ldquo;cat&rdquo; 在文档集合中的 <strong>tf-idf</strong> 值。首先，我们需要计算单词 &ldquo;cat&rdquo; 在每个文档中的 <strong>tf</strong> 值。计算公式如下：</p>
<p>$$\text{tf}(t,d) = \frac{f_{t,d}}{\sum_{t&rsquo; \in d} f_{t&rsquo;,d}}$$</p>
<p>其中，$f_{t,d}$ 表示单词 $t$ 在文档 $d$ 中出现的次数，$\sum_{t&rsquo; \in d} f_{t&rsquo;,d}$ 表示文档 $d$ 中所有单词的出现次数之和。因此，单词 &ldquo;cat&rdquo; 在每个文档中的 <strong>tf</strong> 值为:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#070">tf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">1</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">1</span><span style="color:#333">/</span><span style="color:#070">5</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">2</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#333">/</span><span style="color:#070">5</span> <span style="color:#333">=</span> <span style="color:#070">0</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">3</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">1</span><span style="color:#333">/</span><span style="color:#070">6</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.1667</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">4</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">1</span><span style="color:#333">/</span><span style="color:#070">7</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.1429</span>
</span></span></code></pre></div><p>接下来，我们需要计算单词 &ldquo;cat&rdquo; 在整个文档集合中的 <strong>idf</strong> 值。计算公式如下：</p>
<p>$$\text{idf}(t,D) = \log{\frac{N}{|{d \in D : t \in d}|}}$$</p>
<p>其中，$N$ 表示文档集合中文档的总数，$|{d \in D : t \in d}|$ 表示包含单词 $t$ 的文档数。因此，单词 &ldquo;cat&rdquo; 在整个文档集合中的 <strong>idf</strong> 值为：</p>
<p>$$\text{idf}(cat, D) = \log{\frac{4}{3}} \approx 0.2877$$</p>
<p>最后，我们可以计算单词 &ldquo;cat&rdquo; 在每个文档中的 <strong>tf-idf</strong> 值，计算公式如下：</p>
<p>$$\text{tf-idf}(t,d,D) = \text{tf}(t,d) \cdot \text{idf}(t,D)$$</p>
<p>因此，单词 &ldquo;cat&rdquo; 在每个文档中的 <strong>tf-idf</strong> 值为:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#070">tf-idf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">1</span><span style="color:#333">,</span> <span style="color:#070">D</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2</span> <span style="color:#333">*</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2877</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.0575</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf-idf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">2</span><span style="color:#333">,</span> <span style="color:#070">D</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">0</span> <span style="color:#333">*</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2877</span> <span style="color:#333">=</span> <span style="color:#070">0</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf-idf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">3</span><span style="color:#333">,</span> <span style="color:#070">D</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.1667</span> <span style="color:#333">*</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2877</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.0481</span>
</span></span><span style="display:flex;"><span><span style="color:#070">tf-idf</span><span style="color:#333">(</span><span style="color:#070">cat</span><span style="color:#333">,</span> <span style="color:#070">Doc</span> <span style="color:#070">4</span><span style="color:#333">,</span> <span style="color:#070">D</span><span style="color:#333">)</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.1429</span> <span style="color:#333">*</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.2877</span> <span style="color:#333">=</span> <span style="color:#070">0</span><span style="color:#b06;font-weight:bold">.0412</span>
</span></span></code></pre></div><p>这样，我们就计算出了单词 &ldquo;cat&rdquo; 在每个文档中的 <strong>tf-idf</strong> 值。可以看到，单词 &ldquo;cat&rdquo; 在 Doc 1 和 Doc 3中的 <strong>tf-idf</strong> 值比较高，因为它们在文档中出现得比较少，并且在文档集合中出现的文档数也比较少，表明它们在文档集合中比较重要。</p>
<h3 id="bm25">BM25</h3>
<p>与 <strong>tf-idf</strong> 相似，<strong>BM25</strong> 也是基于词频的算法，但与 <strong>tf-idf</strong> 不同的是，<strong>BM25</strong> 引入了文档长度的因素，同时对词频的权重进行了调整。<strong>BM25</strong> 的全称是 <strong>Best Matching 25</strong>，它计算的是一个查询（query）与一个文档（document）之间的相似度得分。<strong>BM25</strong> 基于以下三个因素来计算文档的得分：</p>
<ol>
<li>
<p>查询项（query term）在文档中的出现次数</p>
</li>
<li>
<p>文档的长度（即包含的单词数）</p>
</li>
<li>
<p>查询项的文档频率（即包含查询项的文档数量）</p>
</li>
</ol>
<p><strong>BM25</strong> 的公式如下：</p>
<p>$$
\text{BM25}(q, d) = \sum_{i=1}^{|q|} \text{idf}(q_i) \cdot \frac{f(q_i, d) \cdot (k_1 + 1)}{f(q_i, d) + k_1 \cdot (1 - b + b \cdot \frac{|d|}{\text{avgdl}})}
$$</p>
<p>其中，</p>
<ul>
<li>$q$ 是查询项</li>
<li>$d$ 是文档</li>
<li>$|q|$ 是查询项的数量</li>
<li>$q_i$ 是第 $i$ 个查询项</li>
<li>$\text{idf}(q_i)$ 是查询项 $q_i$ 的逆文档频率（inverse document frequency），定义为 $\text{idf}(q_i) = \log{\frac{N - n(q_i) + 0.5}{n(q_i) + 0.5}}$
<ul>
<li>$N$ 是文档集合中的文档数</li>
<li>$n(q_i)$ 是包含查询项 $q_i$ 的文档数</li>
</ul>
</li>
<li>$f(q_i, d)$ 是查询项 $q_i$ 在文档 $d$ 中出现的次数</li>
<li>$|d|$ 是文档 $d$ 中的单词数</li>
<li>$\text{avgdl}$ 是文档集合中所有文档的平均长度</li>
<li>$k_1$ 和 $b$ 是常数，通常取 $k_1 = 1.2$，$b = 0.75$</li>
</ul>
<p>在 <strong>BM25</strong> 中，查询项的权重由两个因素决定：逆文档频率（idf）和词频（tf）。与 <strong>tf-idf</strong> 相似，<strong>idf</strong> 用于衡量一个查询项的重要程度，<strong>tf</strong> 用于衡量查询项在文档中的出现频率。不同之处在于，<strong>BM25</strong> 引入了文档长度和查询项的文档频率来对词频进行加权。</p>
<p>具体来说，当文档长度很小时，<strong>BM25</strong> 对词频进行较大的加权，这可以帮助我们区分出现次数很少但重要的查询项；而当文档长度很大时，<strong>BM25</strong> 对词频进行较小的加权，以避免受过多出现的常见查询项的影响。此外，<strong>BM25</strong> 的常数参数 $k_1$ 和 $b$ 也可以根据实际情况进行调整，以获得更好的结果。</p>
<h4 id="计算-bm25-的例子">计算 BM25 的例子：</h4>
<p>假设我们有一个文档集合，其中包含三个文档 $D_1, D_2, D_3$，它们的长度分别为 $|D_1|=100, |D_2|=200, |D_3|=300$。我们还有一个查询项 $q$，其中包含两个单词 $q_1$ 和 $q_2$。假设 $q_1$ 在 $D_1$ 中出现了 2 次，在 $D_2$ 中出现了 5 次，在 $D_3$ 中出现了 10 次；$q_2$ 在 $D_1$ 中出现了 3 次，在 $D_2$ 中出现了 1 次，在 $D_3$ 中没有出现。</p>
<p>我们需要计算每个文档与查询项 $q$ 的 <strong>BM25</strong> 得分。为了简化，我们假设 $k_1 = 1.2$，$b = 0.75$。</p>
<p>首先，我们需要计算每个查询项的逆文档频率 $\text{idf}(q_i)$。根据公式，我们可以得到：</p>
<p>$$\text{idf}(q_1) = \log{\frac{3 - 2 + 0.5}{2 + 0.5}} \approx 0.29$$</p>
<p>$$\text{idf}(q_2) = \log{\frac{3 - 0 + 0.5}{0 + 0.5}} \approx 1.79$$</p>
<p>接下来，我们需要计算每个文档与查询项 $q$ 的 BM25 得分。根据公式，我们可以得到：</p>
<p>$$
\text{BM25}(q, D_1) = \text{idf}(q_1) \cdot \frac{2 \cdot (1.2 + 1)}{2 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{100}{200})} + \text{idf}(q_2) \cdot \frac{3 \cdot (1.2 + 1)}{3 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{100}{200})} \approx 0.78
$$</p>
<p>$$
\text{BM25}(q, D_2) = \text{idf}(q_1) \cdot \frac{5 \cdot (1.2 + 1)}{5 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{200}{200})} + \text{idf}(q_2) \cdot \frac{1 \cdot (1.2 + 1)}{1 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{200}{200})} \approx 0.63
$$</p>
<p>$$
\text{BM25}(q, D_3) = \text{idf}(q_1) \cdot \frac{10 \cdot (1.2 + 1)}{10 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{300}{200})} + \text{idf}(q_2) \cdot \frac{0 \cdot (1.2 + 1)}{0 + 1.2 \cdot (1 - 0.75 + 0.75 \cdot \frac{300}{200})} \approx 0.69
$$</p>
<p>因此，我们可以得到三个文档与查询项 $q$ 的 <strong>BM25</strong> 得分分别为 0.78、0.63 和 0.69。</p>
<p>这个例子说明了，虽然 $q_1$ 在 $D_3$ 中出现的次数最多，但是由于 $D_3$ 的长度较长，而且 $q_2$ 没有在 $D_3$ 中出现，因此 $D_1$ 的得分最高。这也说明了 <strong>BM25</strong> 算法的优点之一，即克服了 <strong>tf-idf</strong> 算法中常见查询项对结果的影响。</p>
<h4 id="bm25的公式进一步解读">BM25的公式进一步解读</h4>
<ul>
<li>
<p><strong>BM25</strong>中的<strong>idf公式</strong>与原版的<strong>idf公式</strong>不一致</p>
<p>传统的 <strong>idf</strong> 公式是 $\log\frac{N}{df}$，其中 $N$ 是文档集合中文档的总数，$df$ 是包含查询项 $t$ 的文档数。而 <strong>BM25</strong> 中使用的 <strong>idf</strong> 公式是 $\log\frac{N-df+0.5}{df+0.5}$。这个公式与传统的 <strong>idf</strong> 公式相比，主要做了两个改动：</p>
<ol>
<li>
<p>加入了平滑因子：在传统的 <strong>idf</strong> 公式中，当某个查询项在文档集合中未出现时，其 <strong>idf</strong> 值会变成负无穷。为了避免这种情况，<strong>BM25</strong> 中的 <strong>idf</strong> 公式加入了平滑因子 0.5。</p>
</li>
<li>
<p>减少 <strong>idf</strong> 的影响：在传统的 <strong>idf</strong> 公式中，当某个查询项在很少的文档中出现时，其 <strong>idf</strong> 值会很大，对结果产生过大的影响。<strong>BM25</strong> 中的 <strong>idf</strong> 公式通过减少 <strong>idf</strong> 的影响，使得查询项在出现文档数较少时，不会对结果产生过大的影响。但是当文档出现的数量超过一半时，计算出的idf值为负数，Lucene中为了解决这个问题，更改了idf公式为$\log1+\frac{N-df+0.5}{df+0.5}$，从而防止了负数的产生。</p>
</li>
</ol>
</li>
<li>
<p><strong>BM25</strong>中的k是如何影响计算出的结果
$k$ 的值控制了词频对得分的影响程度，可以看作是一个词频的归一化因子。</p>
<p>当 $k$ 的值较小时，词频的影响就相对较小，得分的变化范围也相对较小；当 $k$ 的值较大时，词频的影响就相对较大，得分的变化范围也相对较大。当 $k$ 的值等于 $0$ 时，相当于将文档中所有词项的词频都视为 $1$，此时得分只与文档与查询语句的匹配程度有关。同时，因为有$k$的存在，即使词频特别大，也不会对最终计算的结果有大的影响。即当词频达到一定程度，计算出的BM25的值并不会线性提升。</p>
</li>
<li>
<p><strong>BM25</strong>中的b是如何影响计算出的结果
在 BM25 中，参数 $b$ 用来平衡文档长度对得分的影响。它控制了文档长度对得分的影响程度，可以看作是一个文档长度的归一化因子。$b$ 的取值会影响文档中的词项权重 $w_i$ 的大小，这里的 $w_i$ 是指包含词项 $i$ 的文档的 $i$ 的权重。当 $b$ 越大时，表示文档长度对词项权重的影响越大，这意味着文档中的词项权重 $w_i$ 会相应地趋于缩小；反之，当 $b$ 越小时，表示文档长度对词项权重的影响越小，这意味着文档中的词项权重 $w_i$ 会相应地趋于扩大。</p>
</li>
<li>
<p><strong>BM25</strong>中的文档长度如何影响计算出的结果</p>
<p>一篇文档如果所含的单词越少，那么 $\frac{|d|}{\text{avgdl}}$ 越小，从而导致最终的<strong>BM25</strong>越大，因此文档字数越少，相关性越高.</p>
</li>
<li>
<p><strong>idf</strong>为什么要用对数计算?
在计算文档中每个词项的逆文档频率时，使用对数函数的目的是将idf值的范围压缩到一个较小的区间内。由于文档的大小通常会很大，因此一个词项可能会出现几千甚至几十万次，这样计算得到的idf值就会非常大。使用对数函数可以将这些大数值压缩到一个较小的区间内，便于计算和处理。
此外，对数函数还能够使得低频词项的idf值更加突出。如果不使用对数函数，那么在某些情况下，一些低频词项的idf值可能会非常小，甚至可能会被忽略。而使用对数函数后，这些低频词项的idf值就会被放大，使得它们在检索时能够更好地区分文档的相关性。</p>
</li>
</ul>
<h3 id="bm25f">BM25F</h3>
<p><strong>BM25F</strong>是<strong>BM25</strong>算法的一种变体，它在<strong>BM25</strong>的基础上增加了对多字段的支持。在<strong>BM25F</strong>中，每个文档可以包含多个字段（例如标题、正文、标签等），每个字段都有一个权重。<strong>BM25F</strong>通过将每个字段的得分相加来计算文档的相关性得分。<strong>BM25F</strong>的公式如下：</p>
<p>$score(D,Q) = \sum_{i=1}^{n}weight(q_i)\cdot IDF(q_i)\cdot \frac{f(q_i,D)\cdot (k_i + 1)}{f(q_i,D) + k_i\cdot (1 - b_i + b_i \cdot \frac{|D|}{avgdl_i})}$</p>
<p>其中，$D$表示文档，$Q$表示查询，$n$表示查询中的词项数，$q_i$表示查询中的第$i$个词项，$weight(q_i)$表示第$i$个词项的权重，$IDF(q_i)$表示第$i$个词项的逆文档频率，$f(q_i,D)$表示文档$D$中第$i$个词项的出现频率，$k_i$和$b_i$分别表示第$i$个词项的参数$k$和$b$，$|D|$表示文档$D$的长度，$avgdl_i$表示包含第$i$个字段的所有文档的平均长度。</p>
<p>在<strong>BM25F</strong>中，每个词项的权重由其所在的字段的权重和全局权重两部分组成。全局权重表示该词项在整个文集中的重要性，字段权重则表示该词项在当前字段中的重要性。词项的权重可以通过以下公式计算：</p>
<p>$weight(q_i) = weight_{field}(q_i)\cdot weight_{global}(q_i)$</p>
<p>其中，$weight_{field}(q_i)$表示第$i$个词项在当前字段中的权重，$weight_{global}(q_i)$表示第$i$个词项在全局文档集中的权重。</p>
<p><strong>BM25F</strong>的优点是能够有效地处理多字段查询，可以更好地匹配查询和文档中不同字段的相关性。它可以通过调整字段的权重来对不同字段的重要性进行调整，从而提高搜索结果的准确性。</p>
<h3 id="总结">总结</h3>
<ol>
<li>
<p><strong>tf-idf</strong> 词频越高，词频在整个文档集中越稀少，值越高</p>
</li>
<li>
<p><strong>BM25</strong> 词频在整个文档集中越稀少，词频越高，<strong>文档的单词数越少</strong>，值越高</p>
</li>
<li>
<p><strong>BM25F</strong> 词频在整个文档集中越稀少，词频越高， 文档的单词数越少，<strong>权重越高</strong>，值越高</p>
</li>
</ol>

</div>
<div class="tags">
<div class="taxosfloating_left">
<p>Categories</p>
</div>
<div class="termsfloating_right">
<p>
<a href="/categories/full%20text%20search/">full text search</a>
</p>
</div>
<div class="clearit"></div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function() {


if (window.location.hostname == "localhost")
  return;
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
var disqus_shortname = 'tangdh-life';
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</article>
</div>
</main><script src="/js/dark-mode.js"></script>

</body>
</html>
